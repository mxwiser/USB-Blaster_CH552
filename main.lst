                                      1 ;--------------------------------------------------------
                                      2 ; File Created by SDCC : free open source ANSI-C Compiler
                                      3 ; Version 4.2.0 #13081 (Linux)
                                      4 ;--------------------------------------------------------
                                      5 	.module main
                                      6 	.optsdcc -mmcs51 --model-small
                                      7 	
                                      8 ;--------------------------------------------------------
                                      9 ; Public variables in this module
                                     10 ;--------------------------------------------------------
                                     11 	.globl _Manuf_Des
                                     12 	.globl _Prod_Des
                                     13 	.globl _SerDes
                                     14 	.globl _LangDes
                                     15 	.globl _CfgDesc
                                     16 	.globl _DevDesc
                                     17 	.globl _ftdi_rom
                                     18 	.globl _main
                                     19 	.globl _DeviceInterrupt
                                     20 	.globl _USBDeviceEndPointCfg
                                     21 	.globl _USBDeviceIntCfg
                                     22 	.globl _USBDeviceCfg
                                     23 	.globl _CH554SPIMasterWrite
                                     24 	.globl _SPIMasterModeSet
                                     25 	.globl _mDelaymS
                                     26 	.globl _CfgFsys
                                     27 	.globl ___memcpy
                                     28 	.globl _P2B0
                                     29 	.globl _P2B1
                                     30 	.globl _P2B2
                                     31 	.globl _P2B3
                                     32 	.globl _P2B4
                                     33 	.globl _P2B5
                                     34 	.globl _P2B6
                                     35 	.globl _P2B7
                                     36 	.globl _TMS
                                     37 	.globl _ASDO
                                     38 	.globl _NCE
                                     39 	.globl _NCS
                                     40 	.globl _LED
                                     41 	.globl _UIF_BUS_RST
                                     42 	.globl _UIF_DETECT
                                     43 	.globl _UIF_TRANSFER
                                     44 	.globl _UIF_SUSPEND
                                     45 	.globl _UIF_HST_SOF
                                     46 	.globl _UIF_FIFO_OV
                                     47 	.globl _U_SIE_FREE
                                     48 	.globl _U_TOG_OK
                                     49 	.globl _U_IS_NAK
                                     50 	.globl _ADC_CHAN0
                                     51 	.globl _ADC_CHAN1
                                     52 	.globl _CMP_CHAN
                                     53 	.globl _ADC_START
                                     54 	.globl _ADC_IF
                                     55 	.globl _CMP_IF
                                     56 	.globl _CMPO
                                     57 	.globl _U1RI
                                     58 	.globl _U1TI
                                     59 	.globl _U1RB8
                                     60 	.globl _U1TB8
                                     61 	.globl _U1REN
                                     62 	.globl _U1SMOD
                                     63 	.globl _U1SM0
                                     64 	.globl _S0_R_FIFO
                                     65 	.globl _S0_T_FIFO
                                     66 	.globl _S0_FREE
                                     67 	.globl _S0_IF_BYTE
                                     68 	.globl _S0_IF_FIRST
                                     69 	.globl _S0_IF_OV
                                     70 	.globl _S0_FST_ACT
                                     71 	.globl _CP_RL2
                                     72 	.globl _C_T2
                                     73 	.globl _TR2
                                     74 	.globl _EXEN2
                                     75 	.globl _TCLK
                                     76 	.globl _RCLK
                                     77 	.globl _EXF2
                                     78 	.globl _CAP1F
                                     79 	.globl _TF2
                                     80 	.globl _RI
                                     81 	.globl _TI
                                     82 	.globl _RB8
                                     83 	.globl _TB8
                                     84 	.globl _REN
                                     85 	.globl _SM2
                                     86 	.globl _SM1
                                     87 	.globl _SM0
                                     88 	.globl _IT0
                                     89 	.globl _IE0
                                     90 	.globl _IT1
                                     91 	.globl _IE1
                                     92 	.globl _TR0
                                     93 	.globl _TF0
                                     94 	.globl _TR1
                                     95 	.globl _TF1
                                     96 	.globl _RXD
                                     97 	.globl _PWM1_
                                     98 	.globl _TXD
                                     99 	.globl _PWM2_
                                    100 	.globl _AIN3
                                    101 	.globl _VBUS1
                                    102 	.globl _INT0
                                    103 	.globl _TXD1_
                                    104 	.globl _INT1
                                    105 	.globl _T0
                                    106 	.globl _RXD1_
                                    107 	.globl _PWM2
                                    108 	.globl _T1
                                    109 	.globl _UDP
                                    110 	.globl _UDM
                                    111 	.globl _TIN0
                                    112 	.globl _CAP1
                                    113 	.globl _T2
                                    114 	.globl _AIN0
                                    115 	.globl _VBUS2
                                    116 	.globl _TIN1
                                    117 	.globl _CAP2
                                    118 	.globl _T2EX
                                    119 	.globl _RXD_
                                    120 	.globl _TXD_
                                    121 	.globl _AIN1
                                    122 	.globl _UCC1
                                    123 	.globl _TIN2
                                    124 	.globl _SCS
                                    125 	.globl _CAP1_
                                    126 	.globl _T2_
                                    127 	.globl _AIN2
                                    128 	.globl _UCC2
                                    129 	.globl _TIN3
                                    130 	.globl _PWM1
                                    131 	.globl _MOSI
                                    132 	.globl _TIN4
                                    133 	.globl _RXD1
                                    134 	.globl _MISO
                                    135 	.globl _TIN5
                                    136 	.globl _TXD1
                                    137 	.globl _SCK
                                    138 	.globl _IE_SPI0
                                    139 	.globl _IE_TKEY
                                    140 	.globl _IE_USB
                                    141 	.globl _IE_ADC
                                    142 	.globl _IE_UART1
                                    143 	.globl _IE_PWMX
                                    144 	.globl _IE_GPIO
                                    145 	.globl _IE_WDOG
                                    146 	.globl _PX0
                                    147 	.globl _PT0
                                    148 	.globl _PX1
                                    149 	.globl _PT1
                                    150 	.globl _PS
                                    151 	.globl _PT2
                                    152 	.globl _PL_FLAG
                                    153 	.globl _PH_FLAG
                                    154 	.globl _EX0
                                    155 	.globl _ET0
                                    156 	.globl _EX1
                                    157 	.globl _ET1
                                    158 	.globl _ES
                                    159 	.globl _ET2
                                    160 	.globl _E_DIS
                                    161 	.globl _EA
                                    162 	.globl _P
                                    163 	.globl _F1
                                    164 	.globl _OV
                                    165 	.globl _RS0
                                    166 	.globl _RS1
                                    167 	.globl _F0
                                    168 	.globl _AC
                                    169 	.globl _CY
                                    170 	.globl _UEP1_DMA_H
                                    171 	.globl _UEP1_DMA_L
                                    172 	.globl _UEP1_DMA
                                    173 	.globl _UEP0_DMA_H
                                    174 	.globl _UEP0_DMA_L
                                    175 	.globl _UEP0_DMA
                                    176 	.globl _UEP2_3_MOD
                                    177 	.globl _UEP4_1_MOD
                                    178 	.globl _UEP3_DMA_H
                                    179 	.globl _UEP3_DMA_L
                                    180 	.globl _UEP3_DMA
                                    181 	.globl _UEP2_DMA_H
                                    182 	.globl _UEP2_DMA_L
                                    183 	.globl _UEP2_DMA
                                    184 	.globl _USB_DEV_AD
                                    185 	.globl _USB_CTRL
                                    186 	.globl _USB_INT_EN
                                    187 	.globl _UEP4_T_LEN
                                    188 	.globl _UEP4_CTRL
                                    189 	.globl _UEP0_T_LEN
                                    190 	.globl _UEP0_CTRL
                                    191 	.globl _USB_RX_LEN
                                    192 	.globl _USB_MIS_ST
                                    193 	.globl _USB_INT_ST
                                    194 	.globl _USB_INT_FG
                                    195 	.globl _UEP3_T_LEN
                                    196 	.globl _UEP3_CTRL
                                    197 	.globl _UEP2_T_LEN
                                    198 	.globl _UEP2_CTRL
                                    199 	.globl _UEP1_T_LEN
                                    200 	.globl _UEP1_CTRL
                                    201 	.globl _UDEV_CTRL
                                    202 	.globl _USB_C_CTRL
                                    203 	.globl _TKEY_DATH
                                    204 	.globl _TKEY_DATL
                                    205 	.globl _TKEY_DAT
                                    206 	.globl _TKEY_CTRL
                                    207 	.globl _ADC_DATA
                                    208 	.globl _ADC_CFG
                                    209 	.globl _ADC_CTRL
                                    210 	.globl _SBAUD1
                                    211 	.globl _SBUF1
                                    212 	.globl _SCON1
                                    213 	.globl _SPI0_SETUP
                                    214 	.globl _SPI0_CK_SE
                                    215 	.globl _SPI0_CTRL
                                    216 	.globl _SPI0_DATA
                                    217 	.globl _SPI0_STAT
                                    218 	.globl _PWM_CK_SE
                                    219 	.globl _PWM_CTRL
                                    220 	.globl _PWM_DATA1
                                    221 	.globl _PWM_DATA2
                                    222 	.globl _T2CAP1H
                                    223 	.globl _T2CAP1L
                                    224 	.globl _T2CAP1
                                    225 	.globl _TH2
                                    226 	.globl _TL2
                                    227 	.globl _T2COUNT
                                    228 	.globl _RCAP2H
                                    229 	.globl _RCAP2L
                                    230 	.globl _RCAP2
                                    231 	.globl _T2MOD
                                    232 	.globl _T2CON
                                    233 	.globl _SBUF
                                    234 	.globl _SCON
                                    235 	.globl _TH1
                                    236 	.globl _TH0
                                    237 	.globl _TL1
                                    238 	.globl _TL0
                                    239 	.globl _TMOD
                                    240 	.globl _TCON
                                    241 	.globl _XBUS_AUX
                                    242 	.globl _PIN_FUNC
                                    243 	.globl _P3_DIR_PU
                                    244 	.globl _P3_MOD_OC
                                    245 	.globl _P3
                                    246 	.globl _P2
                                    247 	.globl _P1_DIR_PU
                                    248 	.globl _P1_MOD_OC
                                    249 	.globl _P1
                                    250 	.globl _ROM_CTRL
                                    251 	.globl _ROM_DATA_H
                                    252 	.globl _ROM_DATA_L
                                    253 	.globl _ROM_DATA
                                    254 	.globl _ROM_ADDR_H
                                    255 	.globl _ROM_ADDR_L
                                    256 	.globl _ROM_ADDR
                                    257 	.globl _GPIO_IE
                                    258 	.globl _IP_EX
                                    259 	.globl _IE_EX
                                    260 	.globl _IP
                                    261 	.globl _IE
                                    262 	.globl _WDOG_COUNT
                                    263 	.globl _RESET_KEEP
                                    264 	.globl _WAKE_CTRL
                                    265 	.globl _CLOCK_CFG
                                    266 	.globl _PCON
                                    267 	.globl _GLOBAL_CFG
                                    268 	.globl _SAFE_MOD
                                    269 	.globl _DPH
                                    270 	.globl _DPL
                                    271 	.globl _SP
                                    272 	.globl _B
                                    273 	.globl _ACC
                                    274 	.globl _PSW
                                    275 	.globl _Ep2Buffer
                                    276 	.globl _Ep1Buffer
                                    277 	.globl _Ep0Buffer
                                    278 	.globl _receive_buffer
                                    279 	.globl _transmit_buffer
                                    280 	.globl _send_len
                                    281 	.globl _transmit_buffer_out_offset
                                    282 	.globl _transmit_buffer_in_offset
                                    283 	.globl _latency_timer
                                    284 	.globl _ep1_in_busy
                                    285 	.globl _sof_count
                                    286 	.globl _USBBufOutPoint
                                    287 	.globl _USBByteCount
                                    288 	.globl _SetupReqBuf
                                    289 	.globl _pDescr
                                    290 	.globl _send_dummy
                                    291 	.globl _vendor_control
                                    292 	.globl _UsbConfig
                                    293 	.globl _Count
                                    294 	.globl _SetupReq
                                    295 	.globl _SetupLen
                                    296 ;--------------------------------------------------------
                                    297 ; special function registers
                                    298 ;--------------------------------------------------------
                                    299 	.area RSEG    (ABS,DATA)
      000000                        300 	.org 0x0000
                           0000D0   301 _PSW	=	0x00d0
                           0000E0   302 _ACC	=	0x00e0
                           0000F0   303 _B	=	0x00f0
                           000081   304 _SP	=	0x0081
                           000082   305 _DPL	=	0x0082
                           000083   306 _DPH	=	0x0083
                           0000A1   307 _SAFE_MOD	=	0x00a1
                           0000B1   308 _GLOBAL_CFG	=	0x00b1
                           000087   309 _PCON	=	0x0087
                           0000B9   310 _CLOCK_CFG	=	0x00b9
                           0000A9   311 _WAKE_CTRL	=	0x00a9
                           0000FE   312 _RESET_KEEP	=	0x00fe
                           0000FF   313 _WDOG_COUNT	=	0x00ff
                           0000A8   314 _IE	=	0x00a8
                           0000B8   315 _IP	=	0x00b8
                           0000E8   316 _IE_EX	=	0x00e8
                           0000E9   317 _IP_EX	=	0x00e9
                           0000C7   318 _GPIO_IE	=	0x00c7
                           008584   319 _ROM_ADDR	=	0x8584
                           000084   320 _ROM_ADDR_L	=	0x0084
                           000085   321 _ROM_ADDR_H	=	0x0085
                           008F8E   322 _ROM_DATA	=	0x8f8e
                           00008E   323 _ROM_DATA_L	=	0x008e
                           00008F   324 _ROM_DATA_H	=	0x008f
                           000086   325 _ROM_CTRL	=	0x0086
                           000090   326 _P1	=	0x0090
                           000092   327 _P1_MOD_OC	=	0x0092
                           000093   328 _P1_DIR_PU	=	0x0093
                           0000A0   329 _P2	=	0x00a0
                           0000B0   330 _P3	=	0x00b0
                           000096   331 _P3_MOD_OC	=	0x0096
                           000097   332 _P3_DIR_PU	=	0x0097
                           0000C6   333 _PIN_FUNC	=	0x00c6
                           0000A2   334 _XBUS_AUX	=	0x00a2
                           000088   335 _TCON	=	0x0088
                           000089   336 _TMOD	=	0x0089
                           00008A   337 _TL0	=	0x008a
                           00008B   338 _TL1	=	0x008b
                           00008C   339 _TH0	=	0x008c
                           00008D   340 _TH1	=	0x008d
                           000098   341 _SCON	=	0x0098
                           000099   342 _SBUF	=	0x0099
                           0000C8   343 _T2CON	=	0x00c8
                           0000C9   344 _T2MOD	=	0x00c9
                           00CBCA   345 _RCAP2	=	0xcbca
                           0000CA   346 _RCAP2L	=	0x00ca
                           0000CB   347 _RCAP2H	=	0x00cb
                           00CDCC   348 _T2COUNT	=	0xcdcc
                           0000CC   349 _TL2	=	0x00cc
                           0000CD   350 _TH2	=	0x00cd
                           00CFCE   351 _T2CAP1	=	0xcfce
                           0000CE   352 _T2CAP1L	=	0x00ce
                           0000CF   353 _T2CAP1H	=	0x00cf
                           00009B   354 _PWM_DATA2	=	0x009b
                           00009C   355 _PWM_DATA1	=	0x009c
                           00009D   356 _PWM_CTRL	=	0x009d
                           00009E   357 _PWM_CK_SE	=	0x009e
                           0000F8   358 _SPI0_STAT	=	0x00f8
                           0000F9   359 _SPI0_DATA	=	0x00f9
                           0000FA   360 _SPI0_CTRL	=	0x00fa
                           0000FB   361 _SPI0_CK_SE	=	0x00fb
                           0000FC   362 _SPI0_SETUP	=	0x00fc
                           0000C0   363 _SCON1	=	0x00c0
                           0000C1   364 _SBUF1	=	0x00c1
                           0000C2   365 _SBAUD1	=	0x00c2
                           000080   366 _ADC_CTRL	=	0x0080
                           00009A   367 _ADC_CFG	=	0x009a
                           00009F   368 _ADC_DATA	=	0x009f
                           0000C3   369 _TKEY_CTRL	=	0x00c3
                           00C5C4   370 _TKEY_DAT	=	0xc5c4
                           0000C4   371 _TKEY_DATL	=	0x00c4
                           0000C5   372 _TKEY_DATH	=	0x00c5
                           000091   373 _USB_C_CTRL	=	0x0091
                           0000D1   374 _UDEV_CTRL	=	0x00d1
                           0000D2   375 _UEP1_CTRL	=	0x00d2
                           0000D3   376 _UEP1_T_LEN	=	0x00d3
                           0000D4   377 _UEP2_CTRL	=	0x00d4
                           0000D5   378 _UEP2_T_LEN	=	0x00d5
                           0000D6   379 _UEP3_CTRL	=	0x00d6
                           0000D7   380 _UEP3_T_LEN	=	0x00d7
                           0000D8   381 _USB_INT_FG	=	0x00d8
                           0000D9   382 _USB_INT_ST	=	0x00d9
                           0000DA   383 _USB_MIS_ST	=	0x00da
                           0000DB   384 _USB_RX_LEN	=	0x00db
                           0000DC   385 _UEP0_CTRL	=	0x00dc
                           0000DD   386 _UEP0_T_LEN	=	0x00dd
                           0000DE   387 _UEP4_CTRL	=	0x00de
                           0000DF   388 _UEP4_T_LEN	=	0x00df
                           0000E1   389 _USB_INT_EN	=	0x00e1
                           0000E2   390 _USB_CTRL	=	0x00e2
                           0000E3   391 _USB_DEV_AD	=	0x00e3
                           00E5E4   392 _UEP2_DMA	=	0xe5e4
                           0000E4   393 _UEP2_DMA_L	=	0x00e4
                           0000E5   394 _UEP2_DMA_H	=	0x00e5
                           00E7E6   395 _UEP3_DMA	=	0xe7e6
                           0000E6   396 _UEP3_DMA_L	=	0x00e6
                           0000E7   397 _UEP3_DMA_H	=	0x00e7
                           0000EA   398 _UEP4_1_MOD	=	0x00ea
                           0000EB   399 _UEP2_3_MOD	=	0x00eb
                           00EDEC   400 _UEP0_DMA	=	0xedec
                           0000EC   401 _UEP0_DMA_L	=	0x00ec
                           0000ED   402 _UEP0_DMA_H	=	0x00ed
                           00EFEE   403 _UEP1_DMA	=	0xefee
                           0000EE   404 _UEP1_DMA_L	=	0x00ee
                           0000EF   405 _UEP1_DMA_H	=	0x00ef
                                    406 ;--------------------------------------------------------
                                    407 ; special function bits
                                    408 ;--------------------------------------------------------
                                    409 	.area RSEG    (ABS,DATA)
      000000                        410 	.org 0x0000
                           0000D7   411 _CY	=	0x00d7
                           0000D6   412 _AC	=	0x00d6
                           0000D5   413 _F0	=	0x00d5
                           0000D4   414 _RS1	=	0x00d4
                           0000D3   415 _RS0	=	0x00d3
                           0000D2   416 _OV	=	0x00d2
                           0000D1   417 _F1	=	0x00d1
                           0000D0   418 _P	=	0x00d0
                           0000AF   419 _EA	=	0x00af
                           0000AE   420 _E_DIS	=	0x00ae
                           0000AD   421 _ET2	=	0x00ad
                           0000AC   422 _ES	=	0x00ac
                           0000AB   423 _ET1	=	0x00ab
                           0000AA   424 _EX1	=	0x00aa
                           0000A9   425 _ET0	=	0x00a9
                           0000A8   426 _EX0	=	0x00a8
                           0000BF   427 _PH_FLAG	=	0x00bf
                           0000BE   428 _PL_FLAG	=	0x00be
                           0000BD   429 _PT2	=	0x00bd
                           0000BC   430 _PS	=	0x00bc
                           0000BB   431 _PT1	=	0x00bb
                           0000BA   432 _PX1	=	0x00ba
                           0000B9   433 _PT0	=	0x00b9
                           0000B8   434 _PX0	=	0x00b8
                           0000EF   435 _IE_WDOG	=	0x00ef
                           0000EE   436 _IE_GPIO	=	0x00ee
                           0000ED   437 _IE_PWMX	=	0x00ed
                           0000EC   438 _IE_UART1	=	0x00ec
                           0000EB   439 _IE_ADC	=	0x00eb
                           0000EA   440 _IE_USB	=	0x00ea
                           0000E9   441 _IE_TKEY	=	0x00e9
                           0000E8   442 _IE_SPI0	=	0x00e8
                           000097   443 _SCK	=	0x0097
                           000097   444 _TXD1	=	0x0097
                           000097   445 _TIN5	=	0x0097
                           000096   446 _MISO	=	0x0096
                           000096   447 _RXD1	=	0x0096
                           000096   448 _TIN4	=	0x0096
                           000095   449 _MOSI	=	0x0095
                           000095   450 _PWM1	=	0x0095
                           000095   451 _TIN3	=	0x0095
                           000095   452 _UCC2	=	0x0095
                           000095   453 _AIN2	=	0x0095
                           000094   454 _T2_	=	0x0094
                           000094   455 _CAP1_	=	0x0094
                           000094   456 _SCS	=	0x0094
                           000094   457 _TIN2	=	0x0094
                           000094   458 _UCC1	=	0x0094
                           000094   459 _AIN1	=	0x0094
                           000093   460 _TXD_	=	0x0093
                           000092   461 _RXD_	=	0x0092
                           000091   462 _T2EX	=	0x0091
                           000091   463 _CAP2	=	0x0091
                           000091   464 _TIN1	=	0x0091
                           000091   465 _VBUS2	=	0x0091
                           000091   466 _AIN0	=	0x0091
                           000090   467 _T2	=	0x0090
                           000090   468 _CAP1	=	0x0090
                           000090   469 _TIN0	=	0x0090
                           0000B7   470 _UDM	=	0x00b7
                           0000B6   471 _UDP	=	0x00b6
                           0000B5   472 _T1	=	0x00b5
                           0000B4   473 _PWM2	=	0x00b4
                           0000B4   474 _RXD1_	=	0x00b4
                           0000B4   475 _T0	=	0x00b4
                           0000B3   476 _INT1	=	0x00b3
                           0000B2   477 _TXD1_	=	0x00b2
                           0000B2   478 _INT0	=	0x00b2
                           0000B2   479 _VBUS1	=	0x00b2
                           0000B2   480 _AIN3	=	0x00b2
                           0000B1   481 _PWM2_	=	0x00b1
                           0000B1   482 _TXD	=	0x00b1
                           0000B0   483 _PWM1_	=	0x00b0
                           0000B0   484 _RXD	=	0x00b0
                           00008F   485 _TF1	=	0x008f
                           00008E   486 _TR1	=	0x008e
                           00008D   487 _TF0	=	0x008d
                           00008C   488 _TR0	=	0x008c
                           00008B   489 _IE1	=	0x008b
                           00008A   490 _IT1	=	0x008a
                           000089   491 _IE0	=	0x0089
                           000088   492 _IT0	=	0x0088
                           00009F   493 _SM0	=	0x009f
                           00009E   494 _SM1	=	0x009e
                           00009D   495 _SM2	=	0x009d
                           00009C   496 _REN	=	0x009c
                           00009B   497 _TB8	=	0x009b
                           00009A   498 _RB8	=	0x009a
                           000099   499 _TI	=	0x0099
                           000098   500 _RI	=	0x0098
                           0000CF   501 _TF2	=	0x00cf
                           0000CF   502 _CAP1F	=	0x00cf
                           0000CE   503 _EXF2	=	0x00ce
                           0000CD   504 _RCLK	=	0x00cd
                           0000CC   505 _TCLK	=	0x00cc
                           0000CB   506 _EXEN2	=	0x00cb
                           0000CA   507 _TR2	=	0x00ca
                           0000C9   508 _C_T2	=	0x00c9
                           0000C8   509 _CP_RL2	=	0x00c8
                           0000FF   510 _S0_FST_ACT	=	0x00ff
                           0000FE   511 _S0_IF_OV	=	0x00fe
                           0000FD   512 _S0_IF_FIRST	=	0x00fd
                           0000FC   513 _S0_IF_BYTE	=	0x00fc
                           0000FB   514 _S0_FREE	=	0x00fb
                           0000FA   515 _S0_T_FIFO	=	0x00fa
                           0000F8   516 _S0_R_FIFO	=	0x00f8
                           0000C7   517 _U1SM0	=	0x00c7
                           0000C5   518 _U1SMOD	=	0x00c5
                           0000C4   519 _U1REN	=	0x00c4
                           0000C3   520 _U1TB8	=	0x00c3
                           0000C2   521 _U1RB8	=	0x00c2
                           0000C1   522 _U1TI	=	0x00c1
                           0000C0   523 _U1RI	=	0x00c0
                           000087   524 _CMPO	=	0x0087
                           000086   525 _CMP_IF	=	0x0086
                           000085   526 _ADC_IF	=	0x0085
                           000084   527 _ADC_START	=	0x0084
                           000083   528 _CMP_CHAN	=	0x0083
                           000081   529 _ADC_CHAN1	=	0x0081
                           000080   530 _ADC_CHAN0	=	0x0080
                           0000DF   531 _U_IS_NAK	=	0x00df
                           0000DE   532 _U_TOG_OK	=	0x00de
                           0000DD   533 _U_SIE_FREE	=	0x00dd
                           0000DC   534 _UIF_FIFO_OV	=	0x00dc
                           0000DB   535 _UIF_HST_SOF	=	0x00db
                           0000DA   536 _UIF_SUSPEND	=	0x00da
                           0000D9   537 _UIF_TRANSFER	=	0x00d9
                           0000D8   538 _UIF_DETECT	=	0x00d8
                           0000D8   539 _UIF_BUS_RST	=	0x00d8
                           000091   540 _LED	=	0x0091
                           000094   541 _NCS	=	0x0094
                           0000B4   542 _NCE	=	0x00b4
                           0000B3   543 _ASDO	=	0x00b3
                           0000B2   544 _TMS	=	0x00b2
                           0000A7   545 _P2B7	=	0x00a7
                           0000A6   546 _P2B6	=	0x00a6
                           0000A5   547 _P2B5	=	0x00a5
                           0000A4   548 _P2B4	=	0x00a4
                           0000A3   549 _P2B3	=	0x00a3
                           0000A2   550 _P2B2	=	0x00a2
                           0000A1   551 _P2B1	=	0x00a1
                           0000A0   552 _P2B0	=	0x00a0
                                    553 ;--------------------------------------------------------
                                    554 ; overlayable register banks
                                    555 ;--------------------------------------------------------
                                    556 	.area REG_BANK_0	(REL,OVR,DATA)
      000000                        557 	.ds 8
                                    558 ;--------------------------------------------------------
                                    559 ; overlayable bit register bank
                                    560 ;--------------------------------------------------------
                                    561 	.area BIT_BANK	(REL,OVR,DATA)
      000000                        562 bits:
      000000                        563 	.ds 1
                           008000   564 	b0 = bits[0]
                           008100   565 	b1 = bits[1]
                           008200   566 	b2 = bits[2]
                           008300   567 	b3 = bits[3]
                           008400   568 	b4 = bits[4]
                           008500   569 	b5 = bits[5]
                           008600   570 	b6 = bits[6]
                           008700   571 	b7 = bits[7]
                                    572 ;--------------------------------------------------------
                                    573 ; internal ram data
                                    574 ;--------------------------------------------------------
                                    575 	.area DSEG    (DATA)
      000000                        576 _SetupLen::
      000000                        577 	.ds 2
      000002                        578 _SetupReq::
      000002                        579 	.ds 1
      000003                        580 _Count::
      000003                        581 	.ds 1
      000004                        582 _UsbConfig::
      000004                        583 	.ds 1
      000005                        584 _vendor_control::
      000005                        585 	.ds 1
      000006                        586 _send_dummy::
      000006                        587 	.ds 1
      000007                        588 _pDescr::
      000007                        589 	.ds 3
      00000A                        590 _SetupReqBuf::
      00000A                        591 	.ds 8
      000012                        592 _main_length_65536_121:
      000012                        593 	.ds 1
      000013                        594 _main_read_en_65536_121:
      000013                        595 	.ds 1
      000014                        596 _main_timeout_count_65536_121:
      000014                        597 	.ds 2
                                    598 ;--------------------------------------------------------
                                    599 ; overlayable items in internal ram
                                    600 ;--------------------------------------------------------
                                    601 	.area	OSEG    (OVR,DATA)
                                    602 ;--------------------------------------------------------
                                    603 ; Stack segment in internal ram
                                    604 ;--------------------------------------------------------
                                    605 	.area	SSEG
      000000                        606 __start__stack:
      000000                        607 	.ds	1
                                    608 
                                    609 ;--------------------------------------------------------
                                    610 ; indirectly addressable internal ram data
                                    611 ;--------------------------------------------------------
                                    612 	.area ISEG    (DATA)
      000000                        613 _USBByteCount::
      000000                        614 	.ds 1
      000001                        615 _USBBufOutPoint::
      000001                        616 	.ds 1
      000002                        617 _sof_count::
      000002                        618 	.ds 2
      000004                        619 _ep1_in_busy::
      000004                        620 	.ds 1
      000005                        621 _latency_timer::
      000005                        622 	.ds 1
      000006                        623 _transmit_buffer_in_offset::
      000006                        624 	.ds 1
      000007                        625 _transmit_buffer_out_offset::
      000007                        626 	.ds 1
      000008                        627 _send_len::
      000008                        628 	.ds 1
                                    629 ;--------------------------------------------------------
                                    630 ; absolute internal ram data
                                    631 ;--------------------------------------------------------
                                    632 	.area IABS    (ABS,DATA)
                                    633 	.area IABS    (ABS,DATA)
                                    634 ;--------------------------------------------------------
                                    635 ; bit data
                                    636 ;--------------------------------------------------------
                                    637 	.area BSEG    (BIT)
      000000                        638 _DeviceInterrupt_sloc0_1_0:
      000000                        639 	.ds 1
      000001                        640 _main_sloc0_1_0:
      000001                        641 	.ds 1
                                    642 ;--------------------------------------------------------
                                    643 ; paged external ram data
                                    644 ;--------------------------------------------------------
                                    645 	.area PSEG    (PAG,XDATA)
                                    646 ;--------------------------------------------------------
                                    647 ; external ram data
                                    648 ;--------------------------------------------------------
                                    649 	.area XSEG    (XDATA)
                           000000   650 _transmit_buffer	=	0x0000
                           000080   651 _receive_buffer	=	0x0080
                           000100   652 _Ep0Buffer	=	0x0100
                           000140   653 _Ep1Buffer	=	0x0140
                           000180   654 _Ep2Buffer	=	0x0180
                                    655 ;--------------------------------------------------------
                                    656 ; absolute external ram data
                                    657 ;--------------------------------------------------------
                                    658 	.area XABS    (ABS,XDATA)
                                    659 ;--------------------------------------------------------
                                    660 ; external initialized ram data
                                    661 ;--------------------------------------------------------
                                    662 	.area XISEG   (XDATA)
                                    663 	.area HOME    (CODE)
                                    664 	.area GSINIT0 (CODE)
                                    665 	.area GSINIT1 (CODE)
                                    666 	.area GSINIT2 (CODE)
                                    667 	.area GSINIT3 (CODE)
                                    668 	.area GSINIT4 (CODE)
                                    669 	.area GSINIT5 (CODE)
                                    670 	.area GSINIT  (CODE)
                                    671 	.area GSFINAL (CODE)
                                    672 	.area CSEG    (CODE)
                                    673 ;--------------------------------------------------------
                                    674 ; interrupt vector
                                    675 ;--------------------------------------------------------
                                    676 	.area HOME    (CODE)
      000000                        677 __interrupt_vect:
      000000 02r00r00         [24]  678 	ljmp	__sdcc_gsinit_startup
      000003 32               [24]  679 	reti
      000004                        680 	.ds	7
      00000B 32               [24]  681 	reti
      00000C                        682 	.ds	7
      000013 32               [24]  683 	reti
      000014                        684 	.ds	7
      00001B 32               [24]  685 	reti
      00001C                        686 	.ds	7
      000023 32               [24]  687 	reti
      000024                        688 	.ds	7
      00002B 32               [24]  689 	reti
      00002C                        690 	.ds	7
      000033 32               [24]  691 	reti
      000034                        692 	.ds	7
      00003B 32               [24]  693 	reti
      00003C                        694 	.ds	7
      000043 02r00r55         [24]  695 	ljmp	_DeviceInterrupt
                                    696 ;--------------------------------------------------------
                                    697 ; global & static initialisations
                                    698 ;--------------------------------------------------------
                                    699 	.area HOME    (CODE)
                                    700 	.area GSINIT  (CODE)
                                    701 	.area GSFINAL (CODE)
                                    702 	.area GSINIT  (CODE)
                                    703 	.globl __sdcc_gsinit_startup
                                    704 	.globl __sdcc_program_startup
                                    705 	.globl __start__stack
                                    706 	.globl __mcs51_genXINIT
                                    707 	.globl __mcs51_genXRAMCLEAR
                                    708 	.globl __mcs51_genRAMCLEAR
                                    709 ;	main.c:122: volatile __idata uint8_t USBByteCount = 0;   //代表USB端点接收到的数据
      000000 78r00            [12]  710 	mov	r0,#_USBByteCount
      000002 76 00            [12]  711 	mov	@r0,#0x00
                                    712 ;	main.c:123: volatile __idata uint8_t USBBufOutPoint = 0; //取数据指针
      000004 78r01            [12]  713 	mov	r0,#_USBBufOutPoint
      000006 76 00            [12]  714 	mov	@r0,#0x00
                                    715 ;	main.c:124: volatile __idata uint16_t sof_count = 0;
      000008 78r02            [12]  716 	mov	r0,#_sof_count
      00000A 76 00            [12]  717 	mov	@r0,#0x00
      00000C 08               [12]  718 	inc	r0
      00000D 76 00            [12]  719 	mov	@r0,#0x00
                                    720 ;	main.c:125: volatile __idata uint8_t ep1_in_busy = 0; //上传端点是否忙标志
      00000F 78r04            [12]  721 	mov	r0,#_ep1_in_busy
      000011 76 00            [12]  722 	mov	@r0,#0x00
                                    723 ;	main.c:126: volatile __idata uint8_t latency_timer = 4;
      000013 78r05            [12]  724 	mov	r0,#_latency_timer
      000015 76 04            [12]  725 	mov	@r0,#0x04
                                    726 	.area GSFINAL (CODE)
      000000 02r00r46         [24]  727 	ljmp	__sdcc_program_startup
                                    728 ;--------------------------------------------------------
                                    729 ; Home
                                    730 ;--------------------------------------------------------
                                    731 	.area HOME    (CODE)
                                    732 	.area HOME    (CODE)
      000046                        733 __sdcc_program_startup:
      000046 02r05rD3         [24]  734 	ljmp	_main
                                    735 ;	return from main will return to caller
                                    736 ;--------------------------------------------------------
                                    737 ; code
                                    738 ;--------------------------------------------------------
                                    739 	.area CSEG    (CODE)
                                    740 ;------------------------------------------------------------
                                    741 ;Allocation info for local variables in function 'USBDeviceCfg'
                                    742 ;------------------------------------------------------------
                                    743 ;	main.c:135: void USBDeviceCfg()
                                    744 ;	-----------------------------------------
                                    745 ;	 function USBDeviceCfg
                                    746 ;	-----------------------------------------
      000000                        747 _USBDeviceCfg:
                           000007   748 	ar7 = 0x07
                           000006   749 	ar6 = 0x06
                           000005   750 	ar5 = 0x05
                           000004   751 	ar4 = 0x04
                           000003   752 	ar3 = 0x03
                           000002   753 	ar2 = 0x02
                           000001   754 	ar1 = 0x01
                           000000   755 	ar0 = 0x00
                                    756 ;	main.c:137: USB_CTRL = 0x00;									   //清空USB控制寄存器
      000000 75 E2 00         [24]  757 	mov	_USB_CTRL,#0x00
                                    758 ;	main.c:138: USB_CTRL &= ~bUC_HOST_MODE;							   //该位为选择设备模式
      000003 53 E2 7F         [24]  759 	anl	_USB_CTRL,#0x7f
                                    760 ;	main.c:139: USB_CTRL |= bUC_DEV_PU_EN | bUC_INT_BUSY | bUC_DMA_EN; //USB设备和内部上拉使能,在中断期间中断标志未清除前自动返回NAK
      000006 43 E2 29         [24]  761 	orl	_USB_CTRL,#0x29
                                    762 ;	main.c:140: USB_DEV_AD = 0x00;									   //设备地址初始化
      000009 75 E3 00         [24]  763 	mov	_USB_DEV_AD,#0x00
                                    764 ;	main.c:143: USB_CTRL &= ~bUC_LOW_SPEED;
      00000C 53 E2 BF         [24]  765 	anl	_USB_CTRL,#0xbf
                                    766 ;	main.c:144: UDEV_CTRL &= ~bUD_LOW_SPEED; //选择全速12M模式，默认方式
      00000F 53 D1 FB         [24]  767 	anl	_UDEV_CTRL,#0xfb
                                    768 ;	main.c:145: UDEV_CTRL = bUD_PD_DIS;		 // 禁止DP/DM下拉电阻
      000012 75 D1 80         [24]  769 	mov	_UDEV_CTRL,#0x80
                                    770 ;	main.c:146: UDEV_CTRL |= bUD_PORT_EN;	//使能物理端口
      000015 43 D1 01         [24]  771 	orl	_UDEV_CTRL,#0x01
                                    772 ;	main.c:147: }
      000018 22               [24]  773 	ret
                                    774 ;------------------------------------------------------------
                                    775 ;Allocation info for local variables in function 'USBDeviceIntCfg'
                                    776 ;------------------------------------------------------------
                                    777 ;	main.c:155: void USBDeviceIntCfg()
                                    778 ;	-----------------------------------------
                                    779 ;	 function USBDeviceIntCfg
                                    780 ;	-----------------------------------------
      000019                        781 _USBDeviceIntCfg:
                                    782 ;	main.c:157: USB_INT_EN |= bUIE_SUSPEND;  //使能设备挂起中断
      000019 43 E1 04         [24]  783 	orl	_USB_INT_EN,#0x04
                                    784 ;	main.c:158: USB_INT_EN |= bUIE_TRANSFER; //使能USB传输完成中断
      00001C 43 E1 02         [24]  785 	orl	_USB_INT_EN,#0x02
                                    786 ;	main.c:159: USB_INT_EN |= bUIE_BUS_RST;  //使能设备模式USB总线复位中断
      00001F 43 E1 01         [24]  787 	orl	_USB_INT_EN,#0x01
                                    788 ;	main.c:160: USB_INT_EN |= bUIE_DEV_SOF;	 //For timeout count.
      000022 43 E1 80         [24]  789 	orl	_USB_INT_EN,#0x80
                                    790 ;	main.c:161: USB_INT_FG |= 0x1F;			 //清中断标志
      000025 43 D8 1F         [24]  791 	orl	_USB_INT_FG,#0x1f
                                    792 ;	main.c:162: IE_USB = 1;					 //使能USB中断
                                    793 ;	assignBit
      000028 D2 EA            [12]  794 	setb	_IE_USB
                                    795 ;	main.c:163: EA = 1;						 //允许单片机中断
                                    796 ;	assignBit
      00002A D2 AF            [12]  797 	setb	_EA
                                    798 ;	main.c:164: }
      00002C 22               [24]  799 	ret
                                    800 ;------------------------------------------------------------
                                    801 ;Allocation info for local variables in function 'USBDeviceEndPointCfg'
                                    802 ;------------------------------------------------------------
                                    803 ;	main.c:172: void USBDeviceEndPointCfg()
                                    804 ;	-----------------------------------------
                                    805 ;	 function USBDeviceEndPointCfg
                                    806 ;	-----------------------------------------
      00002D                        807 _USBDeviceEndPointCfg:
                                    808 ;	main.c:174: UEP1_DMA = (uint16_t)Ep1Buffer; //端点1 IN数据传输地址
      00002D 7E 40            [12]  809 	mov	r6,#_Ep1Buffer
      00002F 7F 01            [12]  810 	mov	r7,#(_Ep1Buffer >> 8)
      000031 8E EE            [24]  811 	mov	((_UEP1_DMA >> 0) & 0xFF),r6
      000033 8F EF            [24]  812 	mov	((_UEP1_DMA >> 8) & 0xFF),r7
                                    813 ;	main.c:175: UEP2_DMA = (uint16_t)Ep2Buffer; //端点2 OUT数据传输地址
      000035 7E 80            [12]  814 	mov	r6,#_Ep2Buffer
      000037 7F 01            [12]  815 	mov	r7,#(_Ep2Buffer >> 8)
      000039 8E E4            [24]  816 	mov	((_UEP2_DMA >> 0) & 0xFF),r6
      00003B 8F E5            [24]  817 	mov	((_UEP2_DMA >> 8) & 0xFF),r7
                                    818 ;	main.c:176: UEP2_3_MOD = 0x08;
      00003D 75 EB 08         [24]  819 	mov	_UEP2_3_MOD,#0x08
                                    820 ;	main.c:177: UEP2_CTRL = bUEP_AUTO_TOG | UEP_R_RES_ACK; //端点2自动翻转同步标志位，OUT返回ACK
      000040 75 D4 10         [24]  821 	mov	_UEP2_CTRL,#0x10
                                    822 ;	main.c:178: UEP1_CTRL = bUEP_AUTO_TOG | UEP_T_RES_NAK; //端点1自动翻转同步标志位，IN事务返回NAK
      000043 75 D2 12         [24]  823 	mov	_UEP1_CTRL,#0x12
                                    824 ;	main.c:179: UEP0_DMA = (uint16_t)Ep0Buffer;			   //端点0数据传输地址
      000046 7E 00            [12]  825 	mov	r6,#_Ep0Buffer
      000048 7F 01            [12]  826 	mov	r7,#(_Ep0Buffer >> 8)
      00004A 8E EC            [24]  827 	mov	((_UEP0_DMA >> 0) & 0xFF),r6
      00004C 8F ED            [24]  828 	mov	((_UEP0_DMA >> 8) & 0xFF),r7
                                    829 ;	main.c:180: UEP4_1_MOD = 0x40;						   //端点1上传缓冲区；端点0单64字节收发缓冲区
      00004E 75 EA 40         [24]  830 	mov	_UEP4_1_MOD,#0x40
                                    831 ;	main.c:181: UEP0_CTRL = UEP_R_RES_ACK | UEP_T_RES_NAK; //手动翻转，OUT事务返回ACK，IN事务返回NAK
      000051 75 DC 02         [24]  832 	mov	_UEP0_CTRL,#0x02
                                    833 ;	main.c:182: }
      000054 22               [24]  834 	ret
                                    835 ;------------------------------------------------------------
                                    836 ;Allocation info for local variables in function 'DeviceInterrupt'
                                    837 ;------------------------------------------------------------
                                    838 ;len                       Allocated to registers r4 r5 
                                    839 ;addr                      Allocated to registers r5 
                                    840 ;------------------------------------------------------------
                                    841 ;	main.c:188: void DeviceInterrupt(void) __interrupt(INT_NO_USB) //USB中断服务程序,使用寄存器组1
                                    842 ;	-----------------------------------------
                                    843 ;	 function DeviceInterrupt
                                    844 ;	-----------------------------------------
      000055                        845 _DeviceInterrupt:
      000055 C0*00            [24]  846 	push	bits
      000057 C0 E0            [24]  847 	push	acc
      000059 C0 F0            [24]  848 	push	b
      00005B C0 82            [24]  849 	push	dpl
      00005D C0 83            [24]  850 	push	dph
      00005F C0 07            [24]  851 	push	(0+7)
      000061 C0 06            [24]  852 	push	(0+6)
      000063 C0 05            [24]  853 	push	(0+5)
      000065 C0 04            [24]  854 	push	(0+4)
      000067 C0 03            [24]  855 	push	(0+3)
      000069 C0 02            [24]  856 	push	(0+2)
      00006B C0 01            [24]  857 	push	(0+1)
      00006D C0 00            [24]  858 	push	(0+0)
      00006F C0 D0            [24]  859 	push	psw
      000071 75 D0 00         [24]  860 	mov	psw,#0x00
                                    861 ;	main.c:191: if (UIF_TRANSFER) //USB传输完成标志
      000074 20 D9 03         [24]  862 	jb	_UIF_TRANSFER,00516$
      000077 02r05r6D         [24]  863 	ljmp	00223$
      00007A                        864 00516$:
                                    865 ;	main.c:193: switch (USB_INT_ST & (MASK_UIS_TOKEN | MASK_UIS_ENDP))
      00007A 74 3F            [12]  866 	mov	a,#0x3f
      00007C 55 D9            [12]  867 	anl	a,_USB_INT_ST
      00007E FF               [12]  868 	mov	r7,a
      00007F FE               [12]  869 	mov	r6,a
      000080 BE 00 03         [24]  870 	cjne	r6,#0x00,00517$
      000083 02r05r65         [24]  871 	ljmp	00219$
      000086                        872 00517$:
      000086 BF 02 02         [24]  873 	cjne	r7,#0x02,00518$
      000089 80 48            [24]  874 	sjmp	00105$
      00008B                        875 00518$:
      00008B BF 10 02         [24]  876 	cjne	r7,#0x10,00519$
      00008E 80 1D            [24]  877 	sjmp	00103$
      000090                        878 00519$:
      000090 BF 11 02         [24]  879 	cjne	r7,#0x11,00520$
      000093 80 18            [24]  880 	sjmp	00103$
      000095                        881 00520$:
      000095 BF 12 02         [24]  882 	cjne	r7,#0x12,00521$
      000098 80 13            [24]  883 	sjmp	00103$
      00009A                        884 00521$:
      00009A BF 20 03         [24]  885 	cjne	r7,#0x20,00522$
      00009D 02r04rEA         [24]  886 	ljmp	00212$
      0000A0                        887 00522$:
      0000A0 BF 21 02         [24]  888 	cjne	r7,#0x21,00523$
      0000A3 80 1C            [24]  889 	sjmp	00104$
      0000A5                        890 00523$:
      0000A5 BF 30 02         [24]  891 	cjne	r7,#0x30,00524$
      0000A8 80 42            [24]  892 	sjmp	00108$
      0000AA                        893 00524$:
      0000AA 02r05r6B         [24]  894 	ljmp	00221$
                                    895 ;	main.c:197: case UIS_TOKEN_SOF | 2:
      0000AD                        896 00103$:
                                    897 ;	main.c:198: sof_count++;
      0000AD 78r02            [12]  898 	mov	r0,#_sof_count
      0000AF 86 06            [24]  899 	mov	ar6,@r0
      0000B1 08               [12]  900 	inc	r0
      0000B2 86 07            [24]  901 	mov	ar7,@r0
      0000B4 78r02            [12]  902 	mov	r0,#_sof_count
      0000B6 74 01            [12]  903 	mov	a,#0x01
      0000B8 2E               [12]  904 	add	a,r6
      0000B9 F6               [12]  905 	mov	@r0,a
      0000BA E4               [12]  906 	clr	a
      0000BB 3F               [12]  907 	addc	a,r7
      0000BC 08               [12]  908 	inc	r0
      0000BD F6               [12]  909 	mov	@r0,a
                                    910 ;	main.c:199: break;
      0000BE 02r05r6B         [24]  911 	ljmp	00221$
                                    912 ;	main.c:201: case UIS_TOKEN_IN | 1: //endpoint 1
      0000C1                        913 00104$:
                                    914 ;	main.c:202: UEP1_T_LEN = 0;
      0000C1 75 D3 00         [24]  915 	mov	_UEP1_T_LEN,#0x00
                                    916 ;	main.c:203: UEP1_CTRL = UEP1_CTRL & ~MASK_UEP_T_RES | UEP_T_RES_NAK; //默认应答NAK
      0000C4 74 FC            [12]  917 	mov	a,#0xfc
      0000C6 55 D2            [12]  918 	anl	a,_UEP1_CTRL
      0000C8 44 02            [12]  919 	orl	a,#0x02
      0000CA F5 D2            [12]  920 	mov	_UEP1_CTRL,a
                                    921 ;	main.c:204: ep1_in_busy = 0;
      0000CC 78r04            [12]  922 	mov	r0,#_ep1_in_busy
      0000CE 76 00            [12]  923 	mov	@r0,#0x00
                                    924 ;	main.c:205: break;
      0000D0 02r05r6B         [24]  925 	ljmp	00221$
                                    926 ;	main.c:206: case UIS_TOKEN_OUT | 2: //endpoint 2
      0000D3                        927 00105$:
                                    928 ;	main.c:208: if (U_TOG_OK) // 不同步的数据包将丢弃
      0000D3 20 DE 03         [24]  929 	jb	_U_TOG_OK,00525$
      0000D6 02r05r6B         [24]  930 	ljmp	00221$
      0000D9                        931 00525$:
                                    932 ;	main.c:210: USBByteCount = USB_RX_LEN;
      0000D9 78r00            [12]  933 	mov	r0,#_USBByteCount
      0000DB A6 DB            [24]  934 	mov	@r0,_USB_RX_LEN
                                    935 ;	main.c:211: USBBufOutPoint = 0;										 //取数据指针复位
      0000DD 78r01            [12]  936 	mov	r0,#_USBBufOutPoint
      0000DF 76 00            [12]  937 	mov	@r0,#0x00
                                    938 ;	main.c:212: UEP2_CTRL = UEP2_CTRL & ~MASK_UEP_R_RES | UEP_R_RES_NAK; //收到一包数据就NAK，主函数处理完，由主函数修改响应方式
      0000E1 74 F3            [12]  939 	mov	a,#0xf3
      0000E3 55 D4            [12]  940 	anl	a,_UEP2_CTRL
      0000E5 44 08            [12]  941 	orl	a,#0x08
      0000E7 F5 D4            [12]  942 	mov	_UEP2_CTRL,a
                                    943 ;	main.c:214: break;
      0000E9 02r05r6B         [24]  944 	ljmp	00221$
                                    945 ;	main.c:217: case UIS_TOKEN_SETUP | 0: //SETUP事务
      0000EC                        946 00108$:
                                    947 ;	main.c:218: len = USB_RX_LEN;
      0000EC AE DB            [24]  948 	mov	r6,_USB_RX_LEN
      0000EE 7F 00            [12]  949 	mov	r7,#0x00
                                    950 ;	main.c:219: if (len == (sizeof(USB_SETUP_REQ)))
      0000F0 BE 08 05         [24]  951 	cjne	r6,#0x08,00526$
      0000F3 BF 00 02         [24]  952 	cjne	r7,#0x00,00526$
      0000F6 80 03            [24]  953 	sjmp	00527$
      0000F8                        954 00526$:
      0000F8 02r04rBA         [24]  955 	ljmp	00204$
      0000FB                        956 00527$:
                                    957 ;	main.c:222: SetupLen = ((uint16_t)UsbSetupBuf->wLengthH << 8) | (UsbSetupBuf->wLengthL);
      0000FB 90 01 07         [24]  958 	mov	dptr,#(_Ep0Buffer + 0x0007)
      0000FE E0               [24]  959 	movx	a,@dptr
      0000FF FE               [12]  960 	mov	r6,a
      000100 7F 00            [12]  961 	mov	r7,#0x00
      000102 90 01 06         [24]  962 	mov	dptr,#(_Ep0Buffer + 0x0006)
      000105 E0               [24]  963 	movx	a,@dptr
      000106 7C 00            [12]  964 	mov	r4,#0x00
      000108 4F               [12]  965 	orl	a,r7
      000109 F5*00            [12]  966 	mov	_SetupLen,a
      00010B EC               [12]  967 	mov	a,r4
      00010C 4E               [12]  968 	orl	a,r6
      00010D F5*01            [12]  969 	mov	(_SetupLen + 1),a
                                    970 ;	main.c:223: len = 0;			// 默认为成功并且上传0长度
      00010F 7E 00            [12]  971 	mov	r6,#0x00
      000111 7F 00            [12]  972 	mov	r7,#0x00
                                    973 ;	main.c:224: vendor_control = 0; //默认非vendor
                                    974 ;	1-genFromRTrack replaced	mov	_vendor_control,#0x00
      000113 8F*05            [24]  975 	mov	_vendor_control,r7
                                    976 ;	main.c:225: SetupReq = UsbSetupBuf->bRequest;
      000115 90 01 01         [24]  977 	mov	dptr,#(_Ep0Buffer + 0x0001)
      000118 E0               [24]  978 	movx	a,@dptr
      000119 F5*02            [12]  979 	mov	_SetupReq,a
                                    980 ;	main.c:226: if ((UsbSetupBuf->bRequestType & USB_REQ_TYP_MASK) == USB_REQ_TYP_VENDOR)
      00011B 90 01 00         [24]  981 	mov	dptr,#_Ep0Buffer
      00011E E0               [24]  982 	movx	a,@dptr
      00011F FD               [12]  983 	mov	r5,a
      000120 53 05 60         [24]  984 	anl	ar5,#0x60
      000123 7C 00            [12]  985 	mov	r4,#0x00
      000125 BD 40 05         [24]  986 	cjne	r5,#0x40,00528$
      000128 BC 00 02         [24]  987 	cjne	r4,#0x00,00528$
      00012B 80 03            [24]  988 	sjmp	00529$
      00012D                        989 00528$:
      00012D 02r01rCD         [24]  990 	ljmp	00201$
      000130                        991 00529$:
                                    992 ;	main.c:228: vendor_control = 1;
      000130 75*05 01         [24]  993 	mov	_vendor_control,#0x01
                                    994 ;	main.c:229: if (SetupLen == 0)
      000133 E5*00            [12]  995 	mov	a,_SetupLen
      000135 45*01            [12]  996 	orl	a,(_SetupLen + 1)
      000137 70 22            [24]  997 	jnz	00122$
                                    998 ;	main.c:232: switch (SetupReq)
      000139 E5*02            [12]  999 	mov	a,_SetupReq
      00013B 24 FB            [12] 1000 	add	a,#0xff - 0x04
      00013D 50 03            [24] 1001 	jnc	00531$
      00013F 02r04rBE         [24] 1002 	ljmp	00205$
      000142                       1003 00531$:
      000142 E5*02            [12] 1004 	mov	a,_SetupReq
      000144 75 F0 03         [24] 1005 	mov	b,#0x03
      000147 A4               [48] 1006 	mul	ab
      000148 90r01r4C         [24] 1007 	mov	dptr,#00532$
      00014B 73               [24] 1008 	jmp	@a+dptr
      00014C                       1009 00532$:
      00014C 02r04rBE         [24] 1010 	ljmp	00205$
      00014F 02r04rBE         [24] 1011 	ljmp	00205$
      000152 02r04rBE         [24] 1012 	ljmp	00205$
      000155 02r04rBE         [24] 1013 	ljmp	00205$
      000158 02r04rBE         [24] 1014 	ljmp	00205$
                                   1015 ;	main.c:246: }
      00015B                       1016 00122$:
                                   1017 ;	main.c:251: switch (SetupReq)
      00015B 74 05            [12] 1018 	mov	a,#0x05
      00015D B5*02 02         [24] 1019 	cjne	a,_SetupReq,00533$
      000160 80 3A            [24] 1020 	sjmp	00117$
      000162                       1021 00533$:
      000162 74 09            [12] 1022 	mov	a,#0x09
      000164 B5*02 02         [24] 1023 	cjne	a,_SetupReq,00534$
      000167 80 46            [24] 1024 	sjmp	00118$
      000169                       1025 00534$:
      000169 74 90            [12] 1026 	mov	a,#0x90
      00016B B5*02 4F         [24] 1027 	cjne	a,_SetupReq,00119$
                                   1028 ;	main.c:254: addr = UsbSetupBuf->wIndexL << 1; //((req->wIndex >> 8) & 0x3F) << 1;
      00016E 90 01 04         [24] 1029 	mov	dptr,#(_Ep0Buffer + 0x0004)
      000171 E0               [24] 1030 	movx	a,@dptr
                                   1031 ;	main.c:255: Ep0Buffer[0] = ftdi_rom[addr];
      000172 25 E0            [12] 1032 	add	a,acc
      000174 FD               [12] 1033 	mov	r5,a
      000175 90r00r00         [24] 1034 	mov	dptr,#_ftdi_rom
      000178 93               [24] 1035 	movc	a,@a+dptr
      000179 90 01 00         [24] 1036 	mov	dptr,#_Ep0Buffer
      00017C F0               [24] 1037 	movx	@dptr,a
                                   1038 ;	main.c:256: Ep0Buffer[1] = ftdi_rom[addr + 1];
      00017D 7C 00            [12] 1039 	mov	r4,#0x00
      00017F 0D               [12] 1040 	inc	r5
      000180 BD 00 01         [24] 1041 	cjne	r5,#0x00,00537$
      000183 0C               [12] 1042 	inc	r4
      000184                       1043 00537$:
      000184 ED               [12] 1044 	mov	a,r5
      000185 24r00            [12] 1045 	add	a,#_ftdi_rom
      000187 F5 82            [12] 1046 	mov	dpl,a
      000189 EC               [12] 1047 	mov	a,r4
      00018A 34s00            [12] 1048 	addc	a,#(_ftdi_rom >> 8)
      00018C F5 83            [12] 1049 	mov	dph,a
      00018E E4               [12] 1050 	clr	a
      00018F 93               [24] 1051 	movc	a,@a+dptr
      000190 FD               [12] 1052 	mov	r5,a
      000191 90 01 01         [24] 1053 	mov	dptr,#(_Ep0Buffer + 0x0001)
      000194 F0               [24] 1054 	movx	@dptr,a
                                   1055 ;	main.c:257: len = 2;
      000195 7E 02            [12] 1056 	mov	r6,#0x02
      000197 7F 00            [12] 1057 	mov	r7,#0x00
                                   1058 ;	main.c:258: break;
      000199 02r04rBE         [24] 1059 	ljmp	00205$
                                   1060 ;	main.c:259: case FTDI_VEN_REQ_GET_MODEM_STA:
      00019C                       1061 00117$:
                                   1062 ;	main.c:261: Ep0Buffer[0] = FTDI_MODEM_STA_DUMMY0;
      00019C 90 01 00         [24] 1063 	mov	dptr,#_Ep0Buffer
      00019F 74 31            [12] 1064 	mov	a,#0x31
      0001A1 F0               [24] 1065 	movx	@dptr,a
                                   1066 ;	main.c:262: Ep0Buffer[1] = FTDI_MODEM_STA_DUMMY1;
      0001A2 90 01 01         [24] 1067 	mov	dptr,#(_Ep0Buffer + 0x0001)
      0001A5 74 60            [12] 1068 	mov	a,#0x60
      0001A7 F0               [24] 1069 	movx	@dptr,a
                                   1070 ;	main.c:263: len = 2;
      0001A8 7E 02            [12] 1071 	mov	r6,#0x02
      0001AA 7F 00            [12] 1072 	mov	r7,#0x00
                                   1073 ;	main.c:264: break;
      0001AC 02r04rBE         [24] 1074 	ljmp	00205$
                                   1075 ;	main.c:265: case FTDI_VEN_REQ_SET_LAT_TIMER:
      0001AF                       1076 00118$:
                                   1077 ;	main.c:266: latency_timer = UsbSetupBuf->wValueL;
      0001AF 90 01 02         [24] 1078 	mov	dptr,#(_Ep0Buffer + 0x0002)
      0001B2 78r05            [12] 1079 	mov	r0,#_latency_timer
      0001B4 E0               [24] 1080 	movx	a,@dptr
      0001B5 F6               [12] 1081 	mov	@r0,a
                                   1082 ;	main.c:267: len = 0;
      0001B6 7E 00            [12] 1083 	mov	r6,#0x00
      0001B8 7F 00            [12] 1084 	mov	r7,#0x00
                                   1085 ;	main.c:268: break;
      0001BA 02r04rBE         [24] 1086 	ljmp	00205$
                                   1087 ;	main.c:269: default:
      0001BD                       1088 00119$:
                                   1089 ;	main.c:271: Ep0Buffer[0] = 0x0;
      0001BD 90 01 00         [24] 1090 	mov	dptr,#_Ep0Buffer
      0001C0 E4               [12] 1091 	clr	a
      0001C1 F0               [24] 1092 	movx	@dptr,a
                                   1093 ;	main.c:272: Ep0Buffer[1] = 0x0;
      0001C2 90 01 01         [24] 1094 	mov	dptr,#(_Ep0Buffer + 0x0001)
      0001C5 F0               [24] 1095 	movx	@dptr,a
                                   1096 ;	main.c:273: len = 2;
      0001C6 7E 02            [12] 1097 	mov	r6,#0x02
      0001C8 7F 00            [12] 1098 	mov	r7,#0x00
                                   1099 ;	main.c:275: }
      0001CA 02r04rBE         [24] 1100 	ljmp	00205$
      0001CD                       1101 00201$:
                                   1102 ;	main.c:278: else if ((UsbSetupBuf->bRequestType & USB_REQ_TYP_MASK) == USB_REQ_TYP_STANDARD)
      0001CD 90 01 00         [24] 1103 	mov	dptr,#_Ep0Buffer
      0001D0 E0               [24] 1104 	movx	a,@dptr
      0001D1 FD               [12] 1105 	mov	r5,a
      0001D2 54 60            [12] 1106 	anl	a,#0x60
      0001D4 60 03            [24] 1107 	jz	00539$
      0001D6 02r04rB4         [24] 1108 	ljmp	00195$
      0001D9                       1109 00539$:
                                   1110 ;	main.c:280: switch (SetupReq) //请求码
      0001D9 E5*02            [12] 1111 	mov	a,_SetupReq
      0001DB 24 F5            [12] 1112 	add	a,#0xff - 0x0a
      0001DD 50 03            [24] 1113 	jnc	00540$
      0001DF 02r04rAE         [24] 1114 	ljmp	00193$
      0001E2                       1115 00540$:
      0001E2 E5*02            [12] 1116 	mov	a,_SetupReq
      0001E4 75 F0 03         [24] 1117 	mov	b,#0x03
      0001E7 A4               [48] 1118 	mul	ab
      0001E8 90r01rEC         [24] 1119 	mov	dptr,#00541$
      0001EB 73               [24] 1120 	jmp	@a+dptr
      0001EC                       1121 00541$:
      0001EC 02r04r8C         [24] 1122 	ljmp	00189$
      0001EF 02r03r28         [24] 1123 	ljmp	00147$
      0001F2 02r04rAE         [24] 1124 	ljmp	00193$
      0001F5 02r03rA3         [24] 1125 	ljmp	00164$
      0001F8 02r04rAE         [24] 1126 	ljmp	00193$
      0001FB 02r02rF5         [24] 1127 	ljmp	00141$
      0001FE 02r02r0D         [24] 1128 	ljmp	00124$
      000201 02r04rAE         [24] 1129 	ljmp	00193$
      000204 02r03r02         [24] 1130 	ljmp	00142$
      000207 02r03r1F         [24] 1131 	ljmp	00145$
      00020A 02r04rBE         [24] 1132 	ljmp	00205$
                                   1133 ;	main.c:282: case USB_GET_DESCRIPTOR:
      00020D                       1134 00124$:
                                   1135 ;	main.c:283: switch (UsbSetupBuf->wValueH)
      00020D 90 01 03         [24] 1136 	mov	dptr,#(_Ep0Buffer + 0x0003)
      000210 E0               [24] 1137 	movx	a,@dptr
      000211 FD               [12] 1138 	mov	r5,a
      000212 BD 01 02         [24] 1139 	cjne	r5,#0x01,00542$
      000215 80 0A            [24] 1140 	sjmp	00125$
      000217                       1141 00542$:
      000217 BD 02 02         [24] 1142 	cjne	r5,#0x02,00543$
      00021A 80 14            [24] 1143 	sjmp	00126$
      00021C                       1144 00543$:
                                   1145 ;	main.c:285: case 1:				  //设备描述符
      00021C BD 03 72         [24] 1146 	cjne	r5,#0x03,00137$
      00021F 80 1E            [24] 1147 	sjmp	00127$
      000221                       1148 00125$:
                                   1149 ;	main.c:286: pDescr = DevDesc; //把设备描述符送到要发送的缓冲区
      000221 75*07r80         [24] 1150 	mov	_pDescr,#_DevDesc
      000224 75*08s00         [24] 1151 	mov	(_pDescr + 1),#(_DevDesc >> 8)
      000227 75*09 80         [24] 1152 	mov	(_pDescr + 2),#0x80
                                   1153 ;	main.c:287: len = sizeof(DevDesc);
      00022A 7C 12            [12] 1154 	mov	r4,#0x12
      00022C 7D 00            [12] 1155 	mov	r5,#0x00
                                   1156 ;	main.c:288: break;
                                   1157 ;	main.c:289: case 2:				  //配置描述符
      00022E 80 65            [24] 1158 	sjmp	00138$
      000230                       1159 00126$:
                                   1160 ;	main.c:290: pDescr = CfgDesc; //把设备描述符送到要发送的缓冲区
      000230 75*07r92         [24] 1161 	mov	_pDescr,#_CfgDesc
      000233 75*08s00         [24] 1162 	mov	(_pDescr + 1),#(_CfgDesc >> 8)
      000236 75*09 80         [24] 1163 	mov	(_pDescr + 2),#0x80
                                   1164 ;	main.c:291: len = sizeof(CfgDesc);
      000239 7C 20            [12] 1165 	mov	r4,#0x20
      00023B 7D 00            [12] 1166 	mov	r5,#0x00
                                   1167 ;	main.c:292: break;
                                   1168 ;	main.c:293: case 3:
      00023D 80 56            [24] 1169 	sjmp	00138$
      00023F                       1170 00127$:
                                   1171 ;	main.c:294: if (UsbSetupBuf->wValueL == 0)
      00023F 90 01 02         [24] 1172 	mov	dptr,#(_Ep0Buffer + 0x0002)
      000242 E0               [24] 1173 	movx	a,@dptr
      000243 70 0F            [24] 1174 	jnz	00135$
                                   1175 ;	main.c:296: pDescr = LangDes;
      000245 75*07rB2         [24] 1176 	mov	_pDescr,#_LangDes
      000248 75*08s00         [24] 1177 	mov	(_pDescr + 1),#(_LangDes >> 8)
      00024B 75*09 80         [24] 1178 	mov	(_pDescr + 2),#0x80
                                   1179 ;	main.c:297: len = sizeof(LangDes);
      00024E 7C 04            [12] 1180 	mov	r4,#0x04
      000250 7D 00            [12] 1181 	mov	r5,#0x00
      000252 80 41            [24] 1182 	sjmp	00138$
      000254                       1183 00135$:
                                   1184 ;	main.c:299: else if (UsbSetupBuf->wValueL == 1)
      000254 90 01 02         [24] 1185 	mov	dptr,#(_Ep0Buffer + 0x0002)
      000257 E0               [24] 1186 	movx	a,@dptr
      000258 FB               [12] 1187 	mov	r3,a
      000259 BB 01 0F         [24] 1188 	cjne	r3,#0x01,00132$
                                   1189 ;	main.c:301: pDescr = Manuf_Des;
      00025C 75*07rE0         [24] 1190 	mov	_pDescr,#_Manuf_Des
      00025F 75*08s00         [24] 1191 	mov	(_pDescr + 1),#(_Manuf_Des >> 8)
      000262 75*09 80         [24] 1192 	mov	(_pDescr + 2),#0x80
                                   1193 ;	main.c:302: len = sizeof(Manuf_Des);
      000265 7C 0E            [12] 1194 	mov	r4,#0x0e
      000267 7D 00            [12] 1195 	mov	r5,#0x00
      000269 80 2A            [24] 1196 	sjmp	00138$
      00026B                       1197 00132$:
                                   1198 ;	main.c:304: else if (UsbSetupBuf->wValueL == 2)
      00026B 90 01 02         [24] 1199 	mov	dptr,#(_Ep0Buffer + 0x0002)
      00026E E0               [24] 1200 	movx	a,@dptr
      00026F FB               [12] 1201 	mov	r3,a
      000270 BB 02 0F         [24] 1202 	cjne	r3,#0x02,00129$
                                   1203 ;	main.c:306: pDescr = Prod_Des;
      000273 75*07rC8         [24] 1204 	mov	_pDescr,#_Prod_Des
      000276 75*08s00         [24] 1205 	mov	(_pDescr + 1),#(_Prod_Des >> 8)
      000279 75*09 80         [24] 1206 	mov	(_pDescr + 2),#0x80
                                   1207 ;	main.c:307: len = sizeof(Prod_Des);
      00027C 7C 18            [12] 1208 	mov	r4,#0x18
      00027E 7D 00            [12] 1209 	mov	r5,#0x00
      000280 80 13            [24] 1210 	sjmp	00138$
      000282                       1211 00129$:
                                   1212 ;	main.c:311: pDescr = SerDes;
      000282 75*07rB6         [24] 1213 	mov	_pDescr,#_SerDes
      000285 75*08s00         [24] 1214 	mov	(_pDescr + 1),#(_SerDes >> 8)
      000288 75*09 80         [24] 1215 	mov	(_pDescr + 2),#0x80
                                   1216 ;	main.c:312: len = sizeof(SerDes);
      00028B 7C 12            [12] 1217 	mov	r4,#0x12
      00028D 7D 00            [12] 1218 	mov	r5,#0x00
                                   1219 ;	main.c:314: break;
                                   1220 ;	main.c:315: default:
      00028F 80 04            [24] 1221 	sjmp	00138$
      000291                       1222 00137$:
                                   1223 ;	main.c:316: len = 0xff; //不支持的命令或者出错
      000291 7C FF            [12] 1224 	mov	r4,#0xff
      000293 7D 00            [12] 1225 	mov	r5,#0x00
                                   1226 ;	main.c:318: }
      000295                       1227 00138$:
                                   1228 ;	main.c:319: if (SetupLen > len)
      000295 C3               [12] 1229 	clr	c
      000296 EC               [12] 1230 	mov	a,r4
      000297 95*00            [12] 1231 	subb	a,_SetupLen
      000299 ED               [12] 1232 	mov	a,r5
      00029A 95*01            [12] 1233 	subb	a,(_SetupLen + 1)
      00029C 50 04            [24] 1234 	jnc	00140$
                                   1235 ;	main.c:321: SetupLen = len; //限制总长度
      00029E 8C*00            [24] 1236 	mov	_SetupLen,r4
      0002A0 8D*01            [24] 1237 	mov	(_SetupLen + 1),r5
      0002A2                       1238 00140$:
                                   1239 ;	main.c:323: len = SetupLen >= DEFAULT_ENDP0_SIZE ? DEFAULT_ENDP0_SIZE : SetupLen; //本次传输长度
      0002A2 AC*00            [24] 1240 	mov	r4,_SetupLen
      0002A4 AD*01            [24] 1241 	mov	r5,(_SetupLen + 1)
      0002A6 C3               [12] 1242 	clr	c
      0002A7 EC               [12] 1243 	mov	a,r4
      0002A8 94 08            [12] 1244 	subb	a,#0x08
      0002AA ED               [12] 1245 	mov	a,r5
      0002AB 94 00            [12] 1246 	subb	a,#0x00
      0002AD 92*00            [24] 1247 	mov	_DeviceInterrupt_sloc0_1_0,c
      0002AF 40 06            [24] 1248 	jc	00236$
      0002B1 7C 08            [12] 1249 	mov	r4,#0x08
      0002B3 7D 00            [12] 1250 	mov	r5,#0x00
      0002B5 80 04            [24] 1251 	sjmp	00237$
      0002B7                       1252 00236$:
      0002B7 AC*00            [24] 1253 	mov	r4,_SetupLen
      0002B9 AD*01            [24] 1254 	mov	r5,(_SetupLen + 1)
      0002BB                       1255 00237$:
      0002BB 8C 06            [24] 1256 	mov	ar6,r4
      0002BD 8D 07            [24] 1257 	mov	ar7,r5
                                   1258 ;	main.c:324: memcpy(Ep0Buffer, pDescr, len);										  //加载上传数据
      0002BF 85*07*00         [24] 1259 	mov	___memcpy_PARM_2,_pDescr
      0002C2 85*08*01         [24] 1260 	mov	(___memcpy_PARM_2 + 1),(_pDescr + 1)
      0002C5 85*09*02         [24] 1261 	mov	(___memcpy_PARM_2 + 2),(_pDescr + 2)
      0002C8 8E*00            [24] 1262 	mov	___memcpy_PARM_3,r6
      0002CA 8F*01            [24] 1263 	mov	(___memcpy_PARM_3 + 1),r7
      0002CC 90 01 00         [24] 1264 	mov	dptr,#_Ep0Buffer
      0002CF 75 F0 00         [24] 1265 	mov	b,#0x00
      0002D2 C0 07            [24] 1266 	push	ar7
      0002D4 C0 06            [24] 1267 	push	ar6
      0002D6 12r00r00         [24] 1268 	lcall	___memcpy
      0002D9 D0 06            [24] 1269 	pop	ar6
      0002DB D0 07            [24] 1270 	pop	ar7
                                   1271 ;	main.c:325: SetupLen -= len;
      0002DD E5*00            [12] 1272 	mov	a,_SetupLen
      0002DF C3               [12] 1273 	clr	c
      0002E0 9E               [12] 1274 	subb	a,r6
      0002E1 F5*00            [12] 1275 	mov	_SetupLen,a
      0002E3 E5*01            [12] 1276 	mov	a,(_SetupLen + 1)
      0002E5 9F               [12] 1277 	subb	a,r7
      0002E6 F5*01            [12] 1278 	mov	(_SetupLen + 1),a
                                   1279 ;	main.c:326: pDescr += len;
      0002E8 EE               [12] 1280 	mov	a,r6
      0002E9 25*07            [12] 1281 	add	a,_pDescr
      0002EB F5*07            [12] 1282 	mov	_pDescr,a
      0002ED EF               [12] 1283 	mov	a,r7
      0002EE 35*08            [12] 1284 	addc	a,(_pDescr + 1)
      0002F0 F5*08            [12] 1285 	mov	(_pDescr + 1),a
                                   1286 ;	main.c:327: break;
      0002F2 02r04rBE         [24] 1287 	ljmp	00205$
                                   1288 ;	main.c:328: case USB_SET_ADDRESS:
      0002F5                       1289 00141$:
                                   1290 ;	main.c:329: SetupLen = UsbSetupBuf->wValueL; //暂存USB设备地址
      0002F5 90 01 02         [24] 1291 	mov	dptr,#(_Ep0Buffer + 0x0002)
      0002F8 E0               [24] 1292 	movx	a,@dptr
      0002F9 FD               [12] 1293 	mov	r5,a
      0002FA 8D*00            [24] 1294 	mov	_SetupLen,r5
      0002FC 75*01 00         [24] 1295 	mov	(_SetupLen + 1),#0x00
                                   1296 ;	main.c:330: break;
      0002FF 02r04rBE         [24] 1297 	ljmp	00205$
                                   1298 ;	main.c:331: case USB_GET_CONFIGURATION:
      000302                       1299 00142$:
                                   1300 ;	main.c:332: Ep0Buffer[0] = UsbConfig;
      000302 90 01 00         [24] 1301 	mov	dptr,#_Ep0Buffer
      000305 E5*04            [12] 1302 	mov	a,_UsbConfig
      000307 F0               [24] 1303 	movx	@dptr,a
                                   1304 ;	main.c:333: if (SetupLen >= 1)
      000308 AC*00            [24] 1305 	mov	r4,_SetupLen
      00030A AD*01            [24] 1306 	mov	r5,(_SetupLen + 1)
      00030C C3               [12] 1307 	clr	c
      00030D EC               [12] 1308 	mov	a,r4
      00030E 94 01            [12] 1309 	subb	a,#0x01
      000310 ED               [12] 1310 	mov	a,r5
      000311 94 00            [12] 1311 	subb	a,#0x00
      000313 50 03            [24] 1312 	jnc	00552$
      000315 02r04rBE         [24] 1313 	ljmp	00205$
      000318                       1314 00552$:
                                   1315 ;	main.c:335: len = 1;
      000318 7E 01            [12] 1316 	mov	r6,#0x01
      00031A 7F 00            [12] 1317 	mov	r7,#0x00
                                   1318 ;	main.c:337: break;
      00031C 02r04rBE         [24] 1319 	ljmp	00205$
                                   1320 ;	main.c:338: case USB_SET_CONFIGURATION:
      00031F                       1321 00145$:
                                   1322 ;	main.c:339: UsbConfig = UsbSetupBuf->wValueL;
      00031F 90 01 02         [24] 1323 	mov	dptr,#(_Ep0Buffer + 0x0002)
      000322 E0               [24] 1324 	movx	a,@dptr
      000323 F5*04            [12] 1325 	mov	_UsbConfig,a
                                   1326 ;	main.c:340: break;
      000325 02r04rBE         [24] 1327 	ljmp	00205$
                                   1328 ;	main.c:343: case USB_CLEAR_FEATURE:												//Clear Feature
      000328                       1329 00147$:
                                   1330 ;	main.c:344: if ((UsbSetupBuf->bRequestType & 0x1F) == USB_REQ_RECIP_DEVICE) /* 清除设备 */
      000328 90 01 00         [24] 1331 	mov	dptr,#_Ep0Buffer
      00032B E0               [24] 1332 	movx	a,@dptr
      00032C 54 1F            [12] 1333 	anl	a,#0x1f
      00032E 70 33            [24] 1334 	jnz	00162$
                                   1335 ;	main.c:346: if ((((uint16_t)UsbSetupBuf->wValueH << 8) | UsbSetupBuf->wValueL) == 0x01)
      000330 90 01 03         [24] 1336 	mov	dptr,#(_Ep0Buffer + 0x0003)
      000333 E0               [24] 1337 	movx	a,@dptr
      000334 FC               [12] 1338 	mov	r4,a
      000335 7D 00            [12] 1339 	mov	r5,#0x00
      000337 90 01 02         [24] 1340 	mov	dptr,#(_Ep0Buffer + 0x0002)
      00033A E0               [24] 1341 	movx	a,@dptr
      00033B FB               [12] 1342 	mov	r3,a
      00033C 7A 00            [12] 1343 	mov	r2,#0x00
      00033E 42 05            [12] 1344 	orl	ar5,a
      000340 EA               [12] 1345 	mov	a,r2
      000341 42 04            [12] 1346 	orl	ar4,a
      000343 BD 01 16         [24] 1347 	cjne	r5,#0x01,00152$
      000346 BC 00 13         [24] 1348 	cjne	r4,#0x00,00152$
                                   1349 ;	main.c:348: if (CfgDesc[7] & 0x20)
      000349 90r00r99         [24] 1350 	mov	dptr,#(_CfgDesc + 0x0007)
      00034C E4               [12] 1351 	clr	a
      00034D 93               [24] 1352 	movc	a,@a+dptr
      00034E FD               [12] 1353 	mov	r5,a
      00034F 30 E5 03         [24] 1354 	jnb	acc.5,00557$
      000352 02r04rBE         [24] 1355 	ljmp	00205$
      000355                       1356 00557$:
                                   1357 ;	main.c:354: len = 0xFF; /* 操作失败 */
      000355 7E FF            [12] 1358 	mov	r6,#0xff
      000357 7F 00            [12] 1359 	mov	r7,#0x00
      000359 02r04rBE         [24] 1360 	ljmp	00205$
      00035C                       1361 00152$:
                                   1362 ;	main.c:359: len = 0xFF; /* 操作失败 */
      00035C 7E FF            [12] 1363 	mov	r6,#0xff
      00035E 7F 00            [12] 1364 	mov	r7,#0x00
      000360 02r04rBE         [24] 1365 	ljmp	00205$
      000363                       1366 00162$:
                                   1367 ;	main.c:362: else if ((UsbSetupBuf->bRequestType & USB_REQ_RECIP_MASK) == USB_REQ_RECIP_ENDP) // 端点
      000363 90 01 00         [24] 1368 	mov	dptr,#_Ep0Buffer
      000366 E0               [24] 1369 	movx	a,@dptr
      000367 FD               [12] 1370 	mov	r5,a
      000368 53 05 1F         [24] 1371 	anl	ar5,#0x1f
      00036B 7C 00            [12] 1372 	mov	r4,#0x00
      00036D BD 02 2C         [24] 1373 	cjne	r5,#0x02,00159$
      000370 BC 00 29         [24] 1374 	cjne	r4,#0x00,00159$
                                   1375 ;	main.c:364: switch (UsbSetupBuf->wIndexL)
      000373 90 01 04         [24] 1376 	mov	dptr,#(_Ep0Buffer + 0x0004)
      000376 E0               [24] 1377 	movx	a,@dptr
      000377 FD               [12] 1378 	mov	r5,a
      000378 BD 02 02         [24] 1379 	cjne	r5,#0x02,00560$
      00037B 80 05            [24] 1380 	sjmp	00154$
      00037D                       1381 00560$:
                                   1382 ;	main.c:366: case 0x02:
      00037D BD 81 11         [24] 1383 	cjne	r5,#0x81,00156$
      000380 80 05            [24] 1384 	sjmp	00155$
      000382                       1385 00154$:
                                   1386 ;	main.c:367: UEP2_CTRL = UEP2_CTRL & ~(bUEP_R_TOG | MASK_UEP_R_RES) | UEP_R_RES_ACK;
      000382 53 D4 73         [24] 1387 	anl	_UEP2_CTRL,#0x73
                                   1388 ;	main.c:368: break;
                                   1389 ;	main.c:369: case 0x81:
      000385 80 0E            [24] 1390 	sjmp	00157$
      000387                       1391 00155$:
                                   1392 ;	main.c:370: UEP1_CTRL = UEP1_CTRL & ~(bUEP_T_TOG | MASK_UEP_T_RES) | UEP_T_RES_NAK;
      000387 74 BC            [12] 1393 	mov	a,#0xbc
      000389 55 D2            [12] 1394 	anl	a,_UEP1_CTRL
      00038B 44 02            [12] 1395 	orl	a,#0x02
      00038D F5 D2            [12] 1396 	mov	_UEP1_CTRL,a
                                   1397 ;	main.c:371: break;
                                   1398 ;	main.c:372: default:
      00038F 80 04            [24] 1399 	sjmp	00157$
      000391                       1400 00156$:
                                   1401 ;	main.c:373: len = 0xFF; // 不支持的端点
      000391 7E FF            [12] 1402 	mov	r6,#0xff
      000393 7F 00            [12] 1403 	mov	r7,#0x00
                                   1404 ;	main.c:375: }
      000395                       1405 00157$:
                                   1406 ;	main.c:376: ep1_in_busy = 0;
      000395 78r04            [12] 1407 	mov	r0,#_ep1_in_busy
      000397 76 00            [12] 1408 	mov	@r0,#0x00
      000399 02r04rBE         [24] 1409 	ljmp	00205$
      00039C                       1410 00159$:
                                   1411 ;	main.c:380: len = 0xFF; // 不是端点不支持
      00039C 7E FF            [12] 1412 	mov	r6,#0xff
      00039E 7F 00            [12] 1413 	mov	r7,#0x00
                                   1414 ;	main.c:382: break;
      0003A0 02r04rBE         [24] 1415 	ljmp	00205$
                                   1416 ;	main.c:383: case USB_SET_FEATURE:												/* Set Feature */
      0003A3                       1417 00164$:
                                   1418 ;	main.c:384: if ((UsbSetupBuf->bRequestType & 0x1F) == USB_REQ_RECIP_DEVICE) /* 设置设备 */
      0003A3 90 01 00         [24] 1419 	mov	dptr,#_Ep0Buffer
      0003A6 E0               [24] 1420 	movx	a,@dptr
      0003A7 54 1F            [12] 1421 	anl	a,#0x1f
      0003A9 70 4D            [24] 1422 	jnz	00187$
                                   1423 ;	main.c:386: if ((((uint16_t)UsbSetupBuf->wValueH << 8) | UsbSetupBuf->wValueL) == 0x01)
      0003AB 90 01 03         [24] 1424 	mov	dptr,#(_Ep0Buffer + 0x0003)
      0003AE E0               [24] 1425 	movx	a,@dptr
      0003AF FC               [12] 1426 	mov	r4,a
      0003B0 7D 00            [12] 1427 	mov	r5,#0x00
      0003B2 90 01 02         [24] 1428 	mov	dptr,#(_Ep0Buffer + 0x0002)
      0003B5 E0               [24] 1429 	movx	a,@dptr
      0003B6 FB               [12] 1430 	mov	r3,a
      0003B7 7A 00            [12] 1431 	mov	r2,#0x00
      0003B9 42 05            [12] 1432 	orl	ar5,a
      0003BB EA               [12] 1433 	mov	a,r2
      0003BC 42 04            [12] 1434 	orl	ar4,a
      0003BE BD 01 30         [24] 1435 	cjne	r5,#0x01,00172$
      0003C1 BC 00 2D         [24] 1436 	cjne	r4,#0x00,00172$
                                   1437 ;	main.c:388: if (CfgDesc[7] & 0x20)
      0003C4 90r00r99         [24] 1438 	mov	dptr,#(_CfgDesc + 0x0007)
      0003C7 E4               [12] 1439 	clr	a
      0003C8 93               [24] 1440 	movc	a,@a+dptr
      0003C9 FD               [12] 1441 	mov	r5,a
      0003CA 30 E5 1D         [24] 1442 	jnb	acc.5,00169$
                                   1443 ;	main.c:394: while (XBUS_AUX & bUART0_TX)
      0003CD                       1444 00165$:
      0003CD E5 A2            [12] 1445 	mov	a,_XBUS_AUX
      0003CF 20 E7 FB         [24] 1446 	jb	acc.7,00165$
                                   1447 ;	main.c:398: SAFE_MOD = 0x55;
      0003D2 75 A1 55         [24] 1448 	mov	_SAFE_MOD,#0x55
                                   1449 ;	main.c:399: SAFE_MOD = 0xAA;
      0003D5 75 A1 AA         [24] 1450 	mov	_SAFE_MOD,#0xaa
                                   1451 ;	main.c:400: WAKE_CTRL = bWAK_BY_USB | bWAK_RXD0_LO | bWAK_RXD1_LO; //USB或者RXD0/1有信号时可被唤醒
      0003D8 75 A9 C1         [24] 1452 	mov	_WAKE_CTRL,#0xc1
                                   1453 ;	main.c:401: PCON |= PD;											   //睡眠
      0003DB 43 87 02         [24] 1454 	orl	_PCON,#0x02
                                   1455 ;	main.c:402: SAFE_MOD = 0x55;
      0003DE 75 A1 55         [24] 1456 	mov	_SAFE_MOD,#0x55
                                   1457 ;	main.c:403: SAFE_MOD = 0xAA;
      0003E1 75 A1 AA         [24] 1458 	mov	_SAFE_MOD,#0xaa
                                   1459 ;	main.c:404: WAKE_CTRL = 0x00;
      0003E4 75 A9 00         [24] 1460 	mov	_WAKE_CTRL,#0x00
      0003E7 02r04rBE         [24] 1461 	ljmp	00205$
      0003EA                       1462 00169$:
                                   1463 ;	main.c:408: len = 0xFF; /* 操作失败 */
      0003EA 7E FF            [12] 1464 	mov	r6,#0xff
      0003EC 7F 00            [12] 1465 	mov	r7,#0x00
      0003EE 02r04rBE         [24] 1466 	ljmp	00205$
      0003F1                       1467 00172$:
                                   1468 ;	main.c:413: len = 0xFF; /* 操作失败 */
      0003F1 7E FF            [12] 1469 	mov	r6,#0xff
      0003F3 7F 00            [12] 1470 	mov	r7,#0x00
      0003F5 02r04rBE         [24] 1471 	ljmp	00205$
      0003F8                       1472 00187$:
                                   1473 ;	main.c:416: else if ((UsbSetupBuf->bRequestType & 0x1F) == USB_REQ_RECIP_ENDP) /* 设置端点 */
      0003F8 90 01 00         [24] 1474 	mov	dptr,#_Ep0Buffer
      0003FB E0               [24] 1475 	movx	a,@dptr
      0003FC FD               [12] 1476 	mov	r5,a
      0003FD 53 05 1F         [24] 1477 	anl	ar5,#0x1f
      000400 7C 00            [12] 1478 	mov	r4,#0x00
      000402 BD 02 05         [24] 1479 	cjne	r5,#0x02,00568$
      000405 BC 00 02         [24] 1480 	cjne	r4,#0x00,00568$
      000408 80 02            [24] 1481 	sjmp	00569$
      00040A                       1482 00568$:
      00040A 80 7A            [24] 1483 	sjmp	00184$
      00040C                       1484 00569$:
                                   1485 ;	main.c:418: if ((((uint16_t)UsbSetupBuf->wValueH << 8) | UsbSetupBuf->wValueL) == 0x00)
      00040C 90 01 03         [24] 1486 	mov	dptr,#(_Ep0Buffer + 0x0003)
      00040F E0               [24] 1487 	movx	a,@dptr
      000410 FC               [12] 1488 	mov	r4,a
      000411 7D 00            [12] 1489 	mov	r5,#0x00
      000413 90 01 02         [24] 1490 	mov	dptr,#(_Ep0Buffer + 0x0002)
      000416 E0               [24] 1491 	movx	a,@dptr
      000417 FB               [12] 1492 	mov	r3,a
      000418 7A 00            [12] 1493 	mov	r2,#0x00
      00041A 42 05            [12] 1494 	orl	ar5,a
      00041C EA               [12] 1495 	mov	a,r2
      00041D 42 04            [12] 1496 	orl	ar4,a
      00041F ED               [12] 1497 	mov	a,r5
      000420 4C               [12] 1498 	orl	a,r4
      000421 70 5D            [24] 1499 	jnz	00181$
                                   1500 ;	main.c:420: switch (((uint16_t)UsbSetupBuf->wIndexH << 8) | UsbSetupBuf->wIndexL)
      000423 90 01 05         [24] 1501 	mov	dptr,#(_Ep0Buffer + 0x0005)
      000426 E0               [24] 1502 	movx	a,@dptr
      000427 FC               [12] 1503 	mov	r4,a
      000428 7D 00            [12] 1504 	mov	r5,#0x00
      00042A 90 01 04         [24] 1505 	mov	dptr,#(_Ep0Buffer + 0x0004)
      00042D E0               [24] 1506 	movx	a,@dptr
      00042E FB               [12] 1507 	mov	r3,a
      00042F 7A 00            [12] 1508 	mov	r2,#0x00
      000431 42 05            [12] 1509 	orl	ar5,a
      000433 EA               [12] 1510 	mov	a,r2
      000434 42 04            [12] 1511 	orl	ar4,a
      000436 BD 01 05         [24] 1512 	cjne	r5,#0x01,00571$
      000439 BC 00 02         [24] 1513 	cjne	r4,#0x00,00571$
      00043C 80 34            [24] 1514 	sjmp	00177$
      00043E                       1515 00571$:
      00043E BD 02 05         [24] 1516 	cjne	r5,#0x02,00572$
      000441 BC 00 02         [24] 1517 	cjne	r4,#0x00,00572$
      000444 80 18            [24] 1518 	sjmp	00175$
      000446                       1519 00572$:
      000446 BD 81 05         [24] 1520 	cjne	r5,#0x81,00573$
      000449 BC 00 02         [24] 1521 	cjne	r4,#0x00,00573$
      00044C 80 1A            [24] 1522 	sjmp	00176$
      00044E                       1523 00573$:
      00044E BD 82 29         [24] 1524 	cjne	r5,#0x82,00178$
      000451 BC 00 26         [24] 1525 	cjne	r4,#0x00,00178$
                                   1526 ;	main.c:423: UEP2_CTRL = UEP2_CTRL & (~bUEP_T_TOG) | UEP_T_RES_STALL; /* 设置端点2 IN STALL */
      000454 74 BF            [12] 1527 	mov	a,#0xbf
      000456 55 D4            [12] 1528 	anl	a,_UEP2_CTRL
      000458 44 03            [12] 1529 	orl	a,#0x03
      00045A F5 D4            [12] 1530 	mov	_UEP2_CTRL,a
                                   1531 ;	main.c:424: break;
                                   1532 ;	main.c:425: case 0x02:
      00045C 80 60            [24] 1533 	sjmp	00205$
      00045E                       1534 00175$:
                                   1535 ;	main.c:426: UEP2_CTRL = UEP2_CTRL & (~bUEP_R_TOG) | UEP_R_RES_STALL; /* 设置端点2 OUT Stall */
      00045E 74 7F            [12] 1536 	mov	a,#0x7f
      000460 55 D4            [12] 1537 	anl	a,_UEP2_CTRL
      000462 44 0C            [12] 1538 	orl	a,#0x0c
      000464 F5 D4            [12] 1539 	mov	_UEP2_CTRL,a
                                   1540 ;	main.c:427: break;
                                   1541 ;	main.c:428: case 0x81:
      000466 80 56            [24] 1542 	sjmp	00205$
      000468                       1543 00176$:
                                   1544 ;	main.c:429: UEP1_CTRL = UEP1_CTRL & (~bUEP_T_TOG) | UEP_T_RES_STALL; /* 设置端点1 IN STALL */
      000468 74 BF            [12] 1545 	mov	a,#0xbf
      00046A 55 D2            [12] 1546 	anl	a,_UEP1_CTRL
      00046C 44 03            [12] 1547 	orl	a,#0x03
      00046E F5 D2            [12] 1548 	mov	_UEP1_CTRL,a
                                   1549 ;	main.c:430: break;
                                   1550 ;	main.c:431: case 0x01:
      000470 80 4C            [24] 1551 	sjmp	00205$
      000472                       1552 00177$:
                                   1553 ;	main.c:432: UEP1_CTRL = UEP1_CTRL & (~bUEP_R_TOG) | UEP_R_RES_STALL; /* 设置端点1 OUT Stall */
      000472 74 7F            [12] 1554 	mov	a,#0x7f
      000474 55 D2            [12] 1555 	anl	a,_UEP1_CTRL
      000476 44 0C            [12] 1556 	orl	a,#0x0c
      000478 F5 D2            [12] 1557 	mov	_UEP1_CTRL,a
                                   1558 ;	main.c:433: default:
      00047A                       1559 00178$:
                                   1560 ;	main.c:434: len = 0xFF; /* 操作失败 */
      00047A 7E FF            [12] 1561 	mov	r6,#0xff
      00047C 7F 00            [12] 1562 	mov	r7,#0x00
                                   1563 ;	main.c:436: }
      00047E 80 3E            [24] 1564 	sjmp	00205$
      000480                       1565 00181$:
                                   1566 ;	main.c:440: len = 0xFF; /* 操作失败 */
      000480 7E FF            [12] 1567 	mov	r6,#0xff
      000482 7F 00            [12] 1568 	mov	r7,#0x00
      000484 80 38            [24] 1569 	sjmp	00205$
      000486                       1570 00184$:
                                   1571 ;	main.c:445: len = 0xFF; /* 操作失败 */
      000486 7E FF            [12] 1572 	mov	r6,#0xff
      000488 7F 00            [12] 1573 	mov	r7,#0x00
                                   1574 ;	main.c:447: break;
                                   1575 ;	main.c:448: case USB_GET_STATUS:
      00048A 80 32            [24] 1576 	sjmp	00205$
      00048C                       1577 00189$:
                                   1578 ;	main.c:449: Ep0Buffer[0] = 0x00;
      00048C 90 01 00         [24] 1579 	mov	dptr,#_Ep0Buffer
      00048F E4               [12] 1580 	clr	a
      000490 F0               [24] 1581 	movx	@dptr,a
                                   1582 ;	main.c:450: Ep0Buffer[1] = 0x00;
      000491 90 01 01         [24] 1583 	mov	dptr,#(_Ep0Buffer + 0x0001)
      000494 F0               [24] 1584 	movx	@dptr,a
                                   1585 ;	main.c:451: if (SetupLen >= 2)
      000495 AC*00            [24] 1586 	mov	r4,_SetupLen
      000497 AD*01            [24] 1587 	mov	r5,(_SetupLen + 1)
      000499 C3               [12] 1588 	clr	c
      00049A EC               [12] 1589 	mov	a,r4
      00049B 94 02            [12] 1590 	subb	a,#0x02
      00049D ED               [12] 1591 	mov	a,r5
      00049E 94 00            [12] 1592 	subb	a,#0x00
      0004A0 40 06            [24] 1593 	jc	00191$
                                   1594 ;	main.c:453: len = 2;
      0004A2 7E 02            [12] 1595 	mov	r6,#0x02
      0004A4 7F 00            [12] 1596 	mov	r7,#0x00
      0004A6 80 16            [24] 1597 	sjmp	00205$
      0004A8                       1598 00191$:
                                   1599 ;	main.c:457: len = SetupLen;
      0004A8 AE*00            [24] 1600 	mov	r6,_SetupLen
      0004AA AF*01            [24] 1601 	mov	r7,(_SetupLen + 1)
                                   1602 ;	main.c:459: break;
                                   1603 ;	main.c:460: default:
      0004AC 80 10            [24] 1604 	sjmp	00205$
      0004AE                       1605 00193$:
                                   1606 ;	main.c:461: len = 0xff; //操作失败
      0004AE 7E FF            [12] 1607 	mov	r6,#0xff
      0004B0 7F 00            [12] 1608 	mov	r7,#0x00
                                   1609 ;	main.c:463: }
                                   1610 ;	main.c:470: default:
      0004B2 80 0A            [24] 1611 	sjmp	00205$
      0004B4                       1612 00195$:
                                   1613 ;	main.c:471: len = 0xFF; /*命令不支持*/
      0004B4 7E FF            [12] 1614 	mov	r6,#0xff
      0004B6 7F 00            [12] 1615 	mov	r7,#0x00
                                   1616 ;	main.c:473: }
      0004B8 80 04            [24] 1617 	sjmp	00205$
      0004BA                       1618 00204$:
                                   1619 ;	main.c:478: len = 0xff; //包长度错误
      0004BA 7E FF            [12] 1620 	mov	r6,#0xff
      0004BC 7F 00            [12] 1621 	mov	r7,#0x00
      0004BE                       1622 00205$:
                                   1623 ;	main.c:480: if (len == 0xff)
      0004BE 8E 04            [24] 1624 	mov	ar4,r6
      0004C0 8F 05            [24] 1625 	mov	ar5,r7
      0004C2 BC FF 0C         [24] 1626 	cjne	r4,#0xff,00210$
      0004C5 BD 00 09         [24] 1627 	cjne	r5,#0x00,00210$
                                   1628 ;	main.c:482: SetupReq = 0xFF;
      0004C8 75*02 FF         [24] 1629 	mov	_SetupReq,#0xff
                                   1630 ;	main.c:483: UEP0_CTRL = bUEP_R_TOG | bUEP_T_TOG | UEP_R_RES_STALL | UEP_T_RES_STALL; //STALL
      0004CB 75 DC CF         [24] 1631 	mov	_UEP0_CTRL,#0xcf
      0004CE 02r05r6B         [24] 1632 	ljmp	00221$
      0004D1                       1633 00210$:
                                   1634 ;	main.c:485: else if (len <= DEFAULT_ENDP0_SIZE) //上传数据或者状态阶段返回0长度包
      0004D1 C3               [12] 1635 	clr	c
      0004D2 74 08            [12] 1636 	mov	a,#0x08
      0004D4 9C               [12] 1637 	subb	a,r4
      0004D5 E4               [12] 1638 	clr	a
      0004D6 9D               [12] 1639 	subb	a,r5
      0004D7 40 08            [24] 1640 	jc	00207$
                                   1641 ;	main.c:487: UEP0_T_LEN = len;
      0004D9 8E DD            [24] 1642 	mov	_UEP0_T_LEN,r6
                                   1643 ;	main.c:488: UEP0_CTRL = bUEP_R_TOG | bUEP_T_TOG | UEP_R_RES_ACK | UEP_T_RES_ACK; //默认数据包是DATA1，返回应答ACK
      0004DB 75 DC C0         [24] 1644 	mov	_UEP0_CTRL,#0xc0
      0004DE 02r05r6B         [24] 1645 	ljmp	00221$
      0004E1                       1646 00207$:
                                   1647 ;	main.c:492: UEP0_T_LEN = 0;														 //虽然尚未到状态阶段，但是提前预置上传0长度数据包以防主机提前进入状态阶段
      0004E1 75 DD 00         [24] 1648 	mov	_UEP0_T_LEN,#0x00
                                   1649 ;	main.c:493: UEP0_CTRL = bUEP_R_TOG | bUEP_T_TOG | UEP_R_RES_ACK | UEP_T_RES_ACK; //默认数据包是DATA1,返回应答ACK
      0004E4 75 DC C0         [24] 1650 	mov	_UEP0_CTRL,#0xc0
                                   1651 ;	main.c:495: break;
      0004E7 02r05r6B         [24] 1652 	ljmp	00221$
                                   1653 ;	main.c:496: case UIS_TOKEN_IN | 0: //endpoint0 IN
      0004EA                       1654 00212$:
                                   1655 ;	main.c:497: switch (SetupReq)
      0004EA 74 05            [12] 1656 	mov	a,#0x05
      0004EC B5*02 02         [24] 1657 	cjne	a,_SetupReq,00580$
      0004EF 80 58            [24] 1658 	sjmp	00214$
      0004F1                       1659 00580$:
      0004F1 74 06            [12] 1660 	mov	a,#0x06
      0004F3 B5*02 67         [24] 1661 	cjne	a,_SetupReq,00217$
                                   1662 ;	main.c:500: len = SetupLen >= DEFAULT_ENDP0_SIZE ? DEFAULT_ENDP0_SIZE : SetupLen; //本次传输长度
      0004F6 AE*00            [24] 1663 	mov	r6,_SetupLen
      0004F8 AF*01            [24] 1664 	mov	r7,(_SetupLen + 1)
      0004FA C3               [12] 1665 	clr	c
      0004FB EE               [12] 1666 	mov	a,r6
      0004FC 94 08            [12] 1667 	subb	a,#0x08
      0004FE EF               [12] 1668 	mov	a,r7
      0004FF 94 00            [12] 1669 	subb	a,#0x00
      000501 92*00            [24] 1670 	mov	_DeviceInterrupt_sloc0_1_0,c
      000503 40 06            [24] 1671 	jc	00238$
      000505 7E 08            [12] 1672 	mov	r6,#0x08
      000507 7F 00            [12] 1673 	mov	r7,#0x00
      000509 80 04            [24] 1674 	sjmp	00239$
      00050B                       1675 00238$:
      00050B AE*00            [24] 1676 	mov	r6,_SetupLen
      00050D AF*01            [24] 1677 	mov	r7,(_SetupLen + 1)
      00050F                       1678 00239$:
                                   1679 ;	main.c:501: memcpy(Ep0Buffer, pDescr, len);										  //加载上传数据
      00050F 85*07*00         [24] 1680 	mov	___memcpy_PARM_2,_pDescr
      000512 85*08*01         [24] 1681 	mov	(___memcpy_PARM_2 + 1),(_pDescr + 1)
      000515 85*09*02         [24] 1682 	mov	(___memcpy_PARM_2 + 2),(_pDescr + 2)
      000518 8E*00            [24] 1683 	mov	___memcpy_PARM_3,r6
      00051A 8F*01            [24] 1684 	mov	(___memcpy_PARM_3 + 1),r7
      00051C 90 01 00         [24] 1685 	mov	dptr,#_Ep0Buffer
      00051F 75 F0 00         [24] 1686 	mov	b,#0x00
      000522 C0 07            [24] 1687 	push	ar7
      000524 C0 06            [24] 1688 	push	ar6
      000526 12r00r00         [24] 1689 	lcall	___memcpy
      000529 D0 06            [24] 1690 	pop	ar6
      00052B D0 07            [24] 1691 	pop	ar7
                                   1692 ;	main.c:502: SetupLen -= len;
      00052D E5*00            [12] 1693 	mov	a,_SetupLen
      00052F C3               [12] 1694 	clr	c
      000530 9E               [12] 1695 	subb	a,r6
      000531 F5*00            [12] 1696 	mov	_SetupLen,a
      000533 E5*01            [12] 1697 	mov	a,(_SetupLen + 1)
      000535 9F               [12] 1698 	subb	a,r7
      000536 F5*01            [12] 1699 	mov	(_SetupLen + 1),a
                                   1700 ;	main.c:503: pDescr += len;
      000538 EE               [12] 1701 	mov	a,r6
      000539 25*07            [12] 1702 	add	a,_pDescr
      00053B F5*07            [12] 1703 	mov	_pDescr,a
      00053D EF               [12] 1704 	mov	a,r7
      00053E 35*08            [12] 1705 	addc	a,(_pDescr + 1)
      000540 F5*08            [12] 1706 	mov	(_pDescr + 1),a
                                   1707 ;	main.c:504: UEP0_T_LEN = len;
      000542 8E DD            [24] 1708 	mov	_UEP0_T_LEN,r6
                                   1709 ;	main.c:505: UEP0_CTRL ^= bUEP_T_TOG; //同步标志位翻转
      000544 63 DC 40         [24] 1710 	xrl	_UEP0_CTRL,#0x40
                                   1711 ;	main.c:506: break;
                                   1712 ;	main.c:507: case USB_SET_ADDRESS:
      000547 80 22            [24] 1713 	sjmp	00221$
      000549                       1714 00214$:
                                   1715 ;	main.c:508: if (!vendor_control)
      000549 E5*05            [12] 1716 	mov	a,_vendor_control
      00054B 70 1E            [24] 1717 	jnz	00221$
                                   1718 ;	main.c:510: USB_DEV_AD = USB_DEV_AD & bUDA_GP_BIT | SetupLen;
      00054D E5 E3            [12] 1719 	mov	a,_USB_DEV_AD
      00054F 54 80            [12] 1720 	anl	a,#0x80
      000551 FF               [12] 1721 	mov	r7,a
      000552 E5*00            [12] 1722 	mov	a,_SetupLen
      000554 FE               [12] 1723 	mov	r6,a
      000555 4F               [12] 1724 	orl	a,r7
      000556 F5 E3            [12] 1725 	mov	_USB_DEV_AD,a
                                   1726 ;	main.c:511: UEP0_CTRL = UEP_R_RES_ACK | UEP_T_RES_NAK;
      000558 75 DC 02         [24] 1727 	mov	_UEP0_CTRL,#0x02
                                   1728 ;	main.c:513: break;
                                   1729 ;	main.c:514: default:
      00055B 80 0E            [24] 1730 	sjmp	00221$
      00055D                       1731 00217$:
                                   1732 ;	main.c:515: UEP0_T_LEN = 0; //状态阶段完成中断或者是强制上传0长度数据包结束控制传输
      00055D 75 DD 00         [24] 1733 	mov	_UEP0_T_LEN,#0x00
                                   1734 ;	main.c:516: UEP0_CTRL = UEP_R_RES_ACK | UEP_T_RES_NAK;
      000560 75 DC 02         [24] 1735 	mov	_UEP0_CTRL,#0x02
                                   1736 ;	main.c:519: break;
                                   1737 ;	main.c:520: case UIS_TOKEN_OUT | 0: // endpoint0 OUT
      000563 80 06            [24] 1738 	sjmp	00221$
      000565                       1739 00219$:
                                   1740 ;	main.c:533: UEP0_T_LEN = 0;
      000565 75 DD 00         [24] 1741 	mov	_UEP0_T_LEN,#0x00
                                   1742 ;	main.c:534: UEP0_CTRL |= UEP_R_RES_ACK | UEP_T_RES_ACK; //状态阶段，对IN响应NAK
      000568 85 DC DC         [24] 1743 	mov	_UEP0_CTRL,_UEP0_CTRL
                                   1744 ;	main.c:540: }
      00056B                       1745 00221$:
                                   1746 ;	main.c:541: UIF_TRANSFER = 0; //写0清空中断
                                   1747 ;	assignBit
      00056B C2 D9            [12] 1748 	clr	_UIF_TRANSFER
      00056D                       1749 00223$:
                                   1750 ;	main.c:543: if (UIF_BUS_RST) //设备模式USB总线复位中断
      00056D 30 D8 1D         [24] 1751 	jnb	_UIF_BUS_RST,00225$
                                   1752 ;	main.c:548: UEP0_CTRL = UEP_R_RES_ACK | UEP_T_RES_NAK;
      000570 75 DC 02         [24] 1753 	mov	_UEP0_CTRL,#0x02
                                   1754 ;	main.c:549: UEP1_CTRL = bUEP_AUTO_TOG | UEP_T_RES_NAK;
      000573 75 D2 12         [24] 1755 	mov	_UEP1_CTRL,#0x12
                                   1756 ;	main.c:550: UEP2_CTRL = bUEP_AUTO_TOG | UEP_R_RES_ACK;
      000576 75 D4 10         [24] 1757 	mov	_UEP2_CTRL,#0x10
                                   1758 ;	main.c:551: USB_DEV_AD = 0x00;
      000579 75 E3 00         [24] 1759 	mov	_USB_DEV_AD,#0x00
                                   1760 ;	main.c:552: UIF_SUSPEND = 0;
                                   1761 ;	assignBit
      00057C C2 DA            [12] 1762 	clr	_UIF_SUSPEND
                                   1763 ;	main.c:553: UIF_TRANSFER = 0;
                                   1764 ;	assignBit
      00057E C2 D9            [12] 1765 	clr	_UIF_TRANSFER
                                   1766 ;	main.c:554: UIF_BUS_RST = 0; //清中断标志
                                   1767 ;	assignBit
      000580 C2 D8            [12] 1768 	clr	_UIF_BUS_RST
                                   1769 ;	main.c:556: USBByteCount = 0; //USB端点收到的长度
      000582 78r00            [12] 1770 	mov	r0,#_USBByteCount
      000584 76 00            [12] 1771 	mov	@r0,#0x00
                                   1772 ;	main.c:557: UsbConfig = 0;	//清除配置值
      000586 75*04 00         [24] 1773 	mov	_UsbConfig,#0x00
                                   1774 ;	main.c:558: ep1_in_busy = 0;
      000589 78r04            [12] 1775 	mov	r0,#_ep1_in_busy
      00058B 76 00            [12] 1776 	mov	@r0,#0x00
      00058D                       1777 00225$:
                                   1778 ;	main.c:560: if (UIF_SUSPEND) //USB总线挂起/唤醒完成
                                   1779 ;	main.c:562: UIF_SUSPEND = 0;
                                   1780 ;	assignBit
      00058D 10 DA 02         [24] 1781 	jbc	_UIF_SUSPEND,00586$
      000590 80 21            [24] 1782 	sjmp	00232$
      000592                       1783 00586$:
                                   1784 ;	main.c:563: if (USB_MIS_ST & bUMS_SUSPEND) //挂起
      000592 E5 DA            [12] 1785 	mov	a,_USB_MIS_ST
      000594 30 E2 1F         [24] 1786 	jnb	acc.2,00234$
                                   1787 ;	main.c:568: while (XBUS_AUX & bUART0_TX)
      000597                       1788 00226$:
      000597 E5 A2            [12] 1789 	mov	a,_XBUS_AUX
      000599 20 E7 FB         [24] 1790 	jb	acc.7,00226$
                                   1791 ;	main.c:572: SAFE_MOD = 0x55;
      00059C 75 A1 55         [24] 1792 	mov	_SAFE_MOD,#0x55
                                   1793 ;	main.c:573: SAFE_MOD = 0xAA;
      00059F 75 A1 AA         [24] 1794 	mov	_SAFE_MOD,#0xaa
                                   1795 ;	main.c:574: WAKE_CTRL = bWAK_BY_USB | bWAK_RXD0_LO | bWAK_RXD1_LO; //USB或者RXD0/1有信号时可被唤醒
      0005A2 75 A9 C1         [24] 1796 	mov	_WAKE_CTRL,#0xc1
                                   1797 ;	main.c:575: PCON |= PD;											   //睡眠
      0005A5 43 87 02         [24] 1798 	orl	_PCON,#0x02
                                   1799 ;	main.c:576: SAFE_MOD = 0x55;
      0005A8 75 A1 55         [24] 1800 	mov	_SAFE_MOD,#0x55
                                   1801 ;	main.c:577: SAFE_MOD = 0xAA;
      0005AB 75 A1 AA         [24] 1802 	mov	_SAFE_MOD,#0xaa
                                   1803 ;	main.c:578: WAKE_CTRL = 0x00;
      0005AE 75 A9 00         [24] 1804 	mov	_WAKE_CTRL,#0x00
      0005B1 80 03            [24] 1805 	sjmp	00234$
      0005B3                       1806 00232$:
                                   1807 ;	main.c:583: USB_INT_FG = 0xFF; //清中断标志
      0005B3 75 D8 FF         [24] 1808 	mov	_USB_INT_FG,#0xff
      0005B6                       1809 00234$:
                                   1810 ;	main.c:585: }
      0005B6 D0 D0            [24] 1811 	pop	psw
      0005B8 D0 00            [24] 1812 	pop	(0+0)
      0005BA D0 01            [24] 1813 	pop	(0+1)
      0005BC D0 02            [24] 1814 	pop	(0+2)
      0005BE D0 03            [24] 1815 	pop	(0+3)
      0005C0 D0 04            [24] 1816 	pop	(0+4)
      0005C2 D0 05            [24] 1817 	pop	(0+5)
      0005C4 D0 06            [24] 1818 	pop	(0+6)
      0005C6 D0 07            [24] 1819 	pop	(0+7)
      0005C8 D0 83            [24] 1820 	pop	dph
      0005CA D0 82            [24] 1821 	pop	dpl
      0005CC D0 F0            [24] 1822 	pop	b
      0005CE D0 E0            [24] 1823 	pop	acc
      0005D0 D0*00            [24] 1824 	pop	bits
      0005D2 32               [24] 1825 	reti
                                   1826 ;------------------------------------------------------------
                                   1827 ;Allocation info for local variables in function 'main'
                                   1828 ;------------------------------------------------------------
                                   1829 ;length                    Allocated with name '_main_length_65536_121'
                                   1830 ;read_buffer_index         Allocated to registers r2 
                                   1831 ;shift_count               Allocated to registers r7 
                                   1832 ;operand                   Allocated to registers 
                                   1833 ;shift_en                  Allocated to registers r5 
                                   1834 ;read_en                   Allocated with name '_main_read_en_65536_121'
                                   1835 ;timeout_count             Allocated with name '_main_timeout_count_65536_121'
                                   1836 ;__5242880001              Allocated to registers r6 
                                   1837 ;__5242880003              Allocated to registers r4 
                                   1838 ;__4587520005              Allocated to registers 
                                   1839 ;data_len                  Allocated to registers r6 
                                   1840 ;i                         Allocated to registers r6 
                                   1841 ;------------------------------------------------------------
                                   1842 ;	main.c:691: void main()
                                   1843 ;	-----------------------------------------
                                   1844 ;	 function main
                                   1845 ;	-----------------------------------------
      0005D3                       1846 _main:
                                   1847 ;	main.c:695: uint8_t shift_count = 0;
      0005D3 7F 00            [12] 1848 	mov	r7,#0x00
                                   1849 ;	main.c:698: uint8_t read_en = 0;
                                   1850 ;	1-genFromRTrack replaced	mov	_main_read_en_65536_121,#0x00
      0005D5 8F*13            [24] 1851 	mov	_main_read_en_65536_121,r7
                                   1852 ;	main.c:699: uint16_t timeout_count = 0;
      0005D7 E4               [12] 1853 	clr	a
      0005D8 F5*14            [12] 1854 	mov	_main_timeout_count_65536_121,a
      0005DA F5*15            [12] 1855 	mov	(_main_timeout_count_65536_121 + 1),a
                                   1856 ;	main.c:701: CfgFsys();   //CH559时钟选择配置
      0005DC C0 07            [24] 1857 	push	ar7
      0005DE 12r00r00         [24] 1858 	lcall	_CfgFsys
                                   1859 ;	main.c:702: mDelaymS(5); //修改主频等待内部晶振稳定,必加
      0005E1 90 00 05         [24] 1860 	mov	dptr,#0x0005
      0005E4 12r00r00         [24] 1861 	lcall	_mDelaymS
                                   1862 ;	main.c:704: SPIMasterModeSet(0);
      0005E7 75 82 00         [24] 1863 	mov	dpl,#0x00
      0005EA 12r00r00         [24] 1864 	lcall	_SPIMasterModeSet
                                   1865 ;	main.c:705: SPI_CK_SET(4);
      0005ED 75 FB 04         [24] 1866 	mov	_SPI0_CK_SE,#0x04
                                   1867 ;	main.c:707: USBDeviceCfg();
      0005F0 12r00r00         [24] 1868 	lcall	_USBDeviceCfg
                                   1869 ;	main.c:708: USBDeviceEndPointCfg(); //端点配置
      0005F3 12r00r2D         [24] 1870 	lcall	_USBDeviceEndPointCfg
                                   1871 ;	main.c:709: USBDeviceIntCfg();		//中断初始化
      0005F6 12r00r19         [24] 1872 	lcall	_USBDeviceIntCfg
      0005F9 D0 07            [24] 1873 	pop	ar7
                                   1874 ;	main.c:717: P1_MOD_OC &= ~((1 << 1) | (1 << 5) | (1 << 7)|(1 << 4));
      0005FB 53 92 4D         [24] 1875 	anl	_P1_MOD_OC,#0x4d
                                   1876 ;	main.c:718: P1_MOD_OC |= ((1 << 6));
      0005FE 43 92 40         [24] 1877 	orl	_P1_MOD_OC,#0x40
                                   1878 ;	main.c:719: P1_DIR_PU |= ((1 << 1) | (1 << 5) | (1 << 7) | (1 << 6)|(1 << 4));
      000601 43 93 F2         [24] 1879 	orl	_P1_DIR_PU,#0xf2
                                   1880 ;	main.c:721: P3_MOD_OC &= ~((1 << 2)|(1 << 4));
      000604 53 96 EB         [24] 1881 	anl	_P3_MOD_OC,#0xeb
                                   1882 ;	main.c:722: P3_MOD_OC |= (1 << 3);
      000607 43 96 08         [24] 1883 	orl	_P3_MOD_OC,#0x08
                                   1884 ;	main.c:723: P3_DIR_PU |= ((1 << 2)|(1 << 4)|(1 << 3));
      00060A 43 97 1C         [24] 1885 	orl	_P3_DIR_PU,#0x1c
                                   1886 ;	main.c:737: TDO = 1;
                                   1887 ;	assignBit
      00060D D2 96            [12] 1888 	setb	_MISO
                                   1889 ;	main.c:740: ASDO = 1;
                                   1890 ;	assignBit
      00060F D2 B3            [12] 1891 	setb	_ASDO
                                   1892 ;	main.c:744: UEP0_T_LEN = 0;
      000611 75 DD 00         [24] 1893 	mov	_UEP0_T_LEN,#0x00
                                   1894 ;	main.c:745: UEP1_T_LEN = 0; //预使用发送长度一定要清空
      000614 75 D3 00         [24] 1895 	mov	_UEP1_T_LEN,#0x00
                                   1896 ;	main.c:747: Ep1Buffer[0] = FTDI_MODEM_STA_DUMMY0;
      000617 90 01 40         [24] 1897 	mov	dptr,#_Ep1Buffer
      00061A 74 31            [12] 1898 	mov	a,#0x31
      00061C F0               [24] 1899 	movx	@dptr,a
                                   1900 ;	main.c:748: Ep1Buffer[1] = FTDI_MODEM_STA_DUMMY1;
      00061D 90 01 41         [24] 1901 	mov	dptr,#(_Ep1Buffer + 0x0001)
      000620 74 60            [12] 1902 	mov	a,#0x60
      000622 F0               [24] 1903 	movx	@dptr,a
                                   1904 ;	main.c:750: transmit_buffer_in_offset = 0;
      000623 78r06            [12] 1905 	mov	r0,#_transmit_buffer_in_offset
      000625 76 00            [12] 1906 	mov	@r0,#0x00
                                   1907 ;	main.c:751: transmit_buffer_out_offset = 0;
      000627 78r07            [12] 1908 	mov	r0,#_transmit_buffer_out_offset
      000629 76 00            [12] 1909 	mov	@r0,#0x00
                                   1910 ;	main.c:754: send_dummy = 1;
      00062B 75*06 01         [24] 1911 	mov	_send_dummy,#0x01
                                   1912 ;	main.c:755: LED = 1;
                                   1913 ;	assignBit
      00062E D2 91            [12] 1914 	setb	_LED
                                   1915 ;	main.c:757: while (1)
      000630                       1916 00137$:
                                   1917 ;	main.c:759: if (UsbConfig)
      000630 E5*04            [12] 1918 	mov	a,_UsbConfig
      000632 60 FC            [24] 1919 	jz	00137$
                                   1920 ;	main.c:761: length = 0;
      000634 75*12 00         [24] 1921 	mov	_main_length_65536_121,#0x00
                                   1922 ;	main.c:762: if (USBByteCount) //USB接收端点有数据
      000637 78r00            [12] 1923 	mov	r0,#_USBByteCount
      000639 E6               [12] 1924 	mov	a,@r0
      00063A 70 03            [24] 1925 	jnz	00249$
      00063C 02r06r65         [24] 1926 	ljmp	00157$
      00063F                       1927 00249$:
                                   1928 ;	main.c:781: __endasm;
      00063F C0 07            [24] 1929 	push	ar7
      000641 C0 E0            [24] 1930 	push	a
      000643 05 A2            [12] 1931 	inc	_XBUS_AUX
      000645 90 00 80         [24] 1932 	mov	dptr, #_receive_buffer
      000648 15 A2            [12] 1933 	dec	_XBUS_AUX
      00064A 90 01 80         [24] 1934 	mov	dptr, #_Ep2Buffer
      00064D 85*00 07         [24] 1935 	mov	ar7, _USBByteCount
      000650                       1936 	    1$:
      000650 E0               [24] 1937 	movx	a, @dptr
      000651 A3               [24] 1938 	inc	dptr
      000652 A5                    1939 	.db	#0xA5
      000653 D5 07 FA         [24] 1940 	djnz	ar7, 1$
      000656 D0 E0            [24] 1941 	pop	a
      000658 D0 07            [24] 1942 	pop	ar7
                                   1943 ;	main.c:783: UEP2_CTRL = UEP2_CTRL & ~MASK_UEP_R_RES | UEP_R_RES_ACK;
      00065A 53 D4 F3         [24] 1944 	anl	_UEP2_CTRL,#0xf3
                                   1945 ;	main.c:784: length = USBByteCount;
      00065D 78r00            [12] 1946 	mov	r0,#_USBByteCount
      00065F 86*12            [24] 1947 	mov	_main_length_65536_121,@r0
                                   1948 ;	main.c:785: USBByteCount = 0;
      000661 78r00            [12] 1949 	mov	r0,#_USBByteCount
      000663 76 00            [12] 1950 	mov	@r0,#0x00
                                   1951 ;	main.c:789: while (read_buffer_index < length)
      000665                       1952 00157$:
      000665 7A 00            [12] 1953 	mov	r2,#0x00
      000667                       1954 00120$:
      000667 C3               [12] 1955 	clr	c
      000668 EA               [12] 1956 	mov	a,r2
      000669 95*12            [12] 1957 	subb	a,_main_length_65536_121
      00066B 40 03            [24] 1958 	jc	00250$
      00066D 02r07rD6         [24] 1959 	ljmp	00122$
      000670                       1960 00250$:
                                   1961 ;	main.c:791: P2 = receive_buffer[read_buffer_index];
      000670 EA               [12] 1962 	mov	a,r2
      000671 24 80            [12] 1963 	add	a,#_receive_buffer
      000673 F5 82            [12] 1964 	mov	dpl,a
      000675 E4               [12] 1965 	clr	a
      000676 34 00            [12] 1966 	addc	a,#(_receive_buffer >> 8)
      000678 F5 83            [12] 1967 	mov	dph,a
      00067A E0               [24] 1968 	movx	a,@dptr
      00067B F5 A0            [12] 1969 	mov	_P2,a
                                   1970 ;	main.c:792: read_buffer_index++;
      00067D 0A               [12] 1971 	inc	r2
                                   1972 ;	main.c:795: if (shift_count == 0)
      00067E EF               [12] 1973 	mov	a,r7
      00067F 60 03            [24] 1974 	jz	00251$
      000681 02r07r11         [24] 1975 	ljmp	00118$
      000684                       1976 00251$:
                                   1977 ;	main.c:796: {   SPI0_CTRL = 0x00;
      000684 75 FA 00         [24] 1978 	mov	_SPI0_CTRL,#0x00
                                   1979 ;	main.c:797: shift_en = P2B7;
      000687 A2 A7            [12] 1980 	mov	c,_P2B7
      000689 E4               [12] 1981 	clr	a
      00068A 33               [12] 1982 	rlc	a
      00068B FD               [12] 1983 	mov	r5,a
                                   1984 ;	main.c:798: read_en = P2B6;
      00068C A2 A6            [12] 1985 	mov	c,_P2B6
      00068E E4               [12] 1986 	clr	a
      00068F 33               [12] 1987 	rlc	a
      000690 F5*13            [12] 1988 	mov	_main_read_en_65536_121,a
                                   1989 ;	main.c:799: if (shift_en)
      000692 ED               [12] 1990 	mov	a,r5
      000693 60 0D            [24] 1991 	jz	00109$
                                   1992 ;	main.c:801: shift_count = P2 & 0x3f;
      000695 E5 A0            [12] 1993 	mov	a,_P2
      000697 54 3F            [12] 1994 	anl	a,#0x3f
      000699 FF               [12] 1995 	mov	r7,a
                                   1996 ;	main.c:803: if(NCS)
      00069A 30 94 CA         [24] 1997 	jnb	_NCS,00120$
                                   1998 ;	main.c:804: SPI0_CTRL = 0x60;
      00069D 75 FA 60         [24] 1999 	mov	_SPI0_CTRL,#0x60
      0006A0 80 C5            [24] 2000 	sjmp	00120$
      0006A2                       2001 00109$:
                                   2002 ;	main.c:809: else if (read_en)
      0006A2 E5*13            [12] 2003 	mov	a,_main_read_en_65536_121
      0006A4 60 4F            [24] 2004 	jz	00106$
                                   2005 ;	main.c:811: LED = !P2B5;
      0006A6 A2 A5            [12] 2006 	mov	c,_P2B5
      0006A8 B3               [12] 2007 	cpl	c
      0006A9 92 91            [24] 2008 	mov	_LED,c
                                   2009 ;	main.c:812: TDI = P2B4;
                                   2010 ;	assignBit
      0006AB A2 A4            [12] 2011 	mov	c,_P2B4
      0006AD 92 95            [24] 2012 	mov	_MOSI,c
                                   2013 ;	main.c:813: TMS = P2B1;
                                   2014 ;	assignBit
      0006AF A2 A1            [12] 2015 	mov	c,_P2B1
      0006B1 92 B2            [24] 2016 	mov	_TMS,c
                                   2017 ;	main.c:814: TCK = P2B0;
                                   2018 ;	assignBit
      0006B3 A2 A0            [12] 2019 	mov	c,_P2B0
      0006B5 92 97            [24] 2020 	mov	_SCK,c
                                   2021 ;	main.c:817: NCE = P2B2;
                                   2022 ;	assignBit
      0006B7 A2 A2            [12] 2023 	mov	c,_P2B2
      0006B9 92 B4            [24] 2024 	mov	_NCE,c
                                   2025 ;	main.c:818: NCS = P2B3;
                                   2026 ;	assignBit
      0006BB A2 A3            [12] 2027 	mov	c,_P2B3
      0006BD 92 94            [24] 2028 	mov	_NCS,c
                                   2029 ;	main.c:822: transmit_buffer[transmit_buffer_in_offset] = TDO;
      0006BF 78r06            [12] 2030 	mov	r0,#_transmit_buffer_in_offset
      0006C1 86 82            [24] 2031 	mov	dpl,@r0
      0006C3 75 83 00         [24] 2032 	mov	dph,#(_transmit_buffer >> 8)
      0006C6 A2 96            [12] 2033 	mov	c,_MISO
      0006C8 E4               [12] 2034 	clr	a
      0006C9 33               [12] 2035 	rlc	a
      0006CA F0               [24] 2036 	movx	@dptr,a
                                   2037 ;	main.c:823: transmit_buffer[transmit_buffer_in_offset] |= (ASDO<<1);
      0006CB 78r06            [12] 2038 	mov	r0,#_transmit_buffer_in_offset
      0006CD 86 04            [24] 2039 	mov	ar4,@r0
      0006CF 7D 00            [12] 2040 	mov	r5,#(_transmit_buffer >> 8)
      0006D1 78r06            [12] 2041 	mov	r0,#_transmit_buffer_in_offset
      0006D3 86 82            [24] 2042 	mov	dpl,@r0
      0006D5 75 83 00         [24] 2043 	mov	dph,#(_transmit_buffer >> 8)
      0006D8 E0               [24] 2044 	movx	a,@dptr
      0006D9 FB               [12] 2045 	mov	r3,a
      0006DA A2 B3            [12] 2046 	mov	c,_ASDO
      0006DC E4               [12] 2047 	clr	a
      0006DD 33               [12] 2048 	rlc	a
      0006DE 25 E0            [12] 2049 	add	a,acc
      0006E0 FE               [12] 2050 	mov	r6,a
      0006E1 42 03            [12] 2051 	orl	ar3,a
      0006E3 8C 82            [24] 2052 	mov	dpl,r4
      0006E5 8D 83            [24] 2053 	mov	dph,r5
      0006E7 EB               [12] 2054 	mov	a,r3
      0006E8 F0               [24] 2055 	movx	@dptr,a
                                   2056 ;	main.c:824: transmit_buffer_in_offset++;
      0006E9 78r06            [12] 2057 	mov	r0,#_transmit_buffer_in_offset
      0006EB 06               [12] 2058 	inc	@r0
                                   2059 ;	main.c:825: transmit_buffer_in_offset &= 0x7f;// %= sizeof(transmit_buffer);
      0006EC 78r06            [12] 2060 	mov	r0,#_transmit_buffer_in_offset
      0006EE E6               [12] 2061 	mov	a,@r0
      0006EF 54 7F            [12] 2062 	anl	a,#0x7f
      0006F1 F6               [12] 2063 	mov	@r0,a
      0006F2 02r06r67         [24] 2064 	ljmp	00120$
      0006F5                       2065 00106$:
                                   2066 ;	main.c:839: LED = !P2B5;
      0006F5 A2 A5            [12] 2067 	mov	c,_P2B5
      0006F7 B3               [12] 2068 	cpl	c
      0006F8 92 91            [24] 2069 	mov	_LED,c
                                   2070 ;	main.c:840: TDI = P2B4;
                                   2071 ;	assignBit
      0006FA A2 A4            [12] 2072 	mov	c,_P2B4
      0006FC 92 95            [24] 2073 	mov	_MOSI,c
                                   2074 ;	main.c:841: TMS = P2B1;
                                   2075 ;	assignBit
      0006FE A2 A1            [12] 2076 	mov	c,_P2B1
      000700 92 B2            [24] 2077 	mov	_TMS,c
                                   2078 ;	main.c:842: TCK = P2B0;
                                   2079 ;	assignBit
      000702 A2 A0            [12] 2080 	mov	c,_P2B0
      000704 92 97            [24] 2081 	mov	_SCK,c
                                   2082 ;	main.c:845: NCE = P2B2;
                                   2083 ;	assignBit
      000706 A2 A2            [12] 2084 	mov	c,_P2B2
      000708 92 B4            [24] 2085 	mov	_NCE,c
                                   2086 ;	main.c:846: NCS = P2B3;
                                   2087 ;	assignBit
      00070A A2 A3            [12] 2088 	mov	c,_P2B3
      00070C 92 94            [24] 2089 	mov	_NCS,c
      00070E 02r06r67         [24] 2090 	ljmp	00120$
      000711                       2091 00118$:
                                   2092 ;	main.c:854: shift_count--;
      000711 1F               [12] 2093 	dec	r7
                                   2094 ;	main.c:855: if (read_en)
      000712 E5*13            [12] 2095 	mov	a,_main_read_en_65536_121
      000714 70 03            [24] 2096 	jnz	00255$
      000716 02r07rC3         [24] 2097 	ljmp	00115$
      000719                       2098 00255$:
                                   2099 ;	main.c:861: if(!NCS){
      000719 20 94 77         [24] 2100 	jb	_NCS,00112$
                                   2101 ;	main.c:862: transmit_buffer[transmit_buffer_in_offset] = shift_AS_read_on();
      00071C 78r06            [12] 2102 	mov	r0,#_transmit_buffer_in_offset
      00071E 86 82            [24] 2103 	mov	dpl,@r0
      000720 75 83 00         [24] 2104 	mov	dph,#(_transmit_buffer >> 8)
                                   2105 ;	main.c:646: TDI = P2B0;
                                   2106 ;	assignBit
      000723 A2 A0            [12] 2107 	mov	c,_P2B0
      000725 92 95            [24] 2108 	mov	_MOSI,c
                                   2109 ;	main.c:647: P2B0 = ASDO;
                                   2110 ;	assignBit
      000727 A2 B3            [12] 2111 	mov	c,_ASDO
      000729 92 A0            [24] 2112 	mov	_P2B0,c
                                   2113 ;	main.c:648: TCK = 1;
                                   2114 ;	assignBit
      00072B D2 97            [12] 2115 	setb	_SCK
                                   2116 ;	main.c:649: TCK = 0;
                                   2117 ;	assignBit
      00072D C2 97            [12] 2118 	clr	_SCK
                                   2119 ;	main.c:651: TDI = P2B1;
                                   2120 ;	assignBit
      00072F A2 A1            [12] 2121 	mov	c,_P2B1
      000731 92 95            [24] 2122 	mov	_MOSI,c
                                   2123 ;	main.c:652: P2B1 = ASDO;
                                   2124 ;	assignBit
      000733 A2 B3            [12] 2125 	mov	c,_ASDO
      000735 92 A1            [24] 2126 	mov	_P2B1,c
                                   2127 ;	main.c:653: TCK = 1;
                                   2128 ;	assignBit
      000737 D2 97            [12] 2129 	setb	_SCK
                                   2130 ;	main.c:654: TCK = 0;
                                   2131 ;	assignBit
      000739 C2 97            [12] 2132 	clr	_SCK
                                   2133 ;	main.c:656: TDI = P2B2;
                                   2134 ;	assignBit
      00073B A2 A2            [12] 2135 	mov	c,_P2B2
      00073D 92 95            [24] 2136 	mov	_MOSI,c
                                   2137 ;	main.c:657: P2B2 = ASDO;
                                   2138 ;	assignBit
      00073F A2 B3            [12] 2139 	mov	c,_ASDO
      000741 92 A2            [24] 2140 	mov	_P2B2,c
                                   2141 ;	main.c:658: TCK = 1;
                                   2142 ;	assignBit
      000743 D2 97            [12] 2143 	setb	_SCK
                                   2144 ;	main.c:659: TCK = 0;
                                   2145 ;	assignBit
      000745 C2 97            [12] 2146 	clr	_SCK
                                   2147 ;	main.c:661: TDI = P2B3;
                                   2148 ;	assignBit
      000747 A2 A3            [12] 2149 	mov	c,_P2B3
      000749 92 95            [24] 2150 	mov	_MOSI,c
                                   2151 ;	main.c:662: P2B3 = ASDO;
                                   2152 ;	assignBit
      00074B A2 B3            [12] 2153 	mov	c,_ASDO
      00074D 92 A3            [24] 2154 	mov	_P2B3,c
                                   2155 ;	main.c:663: TCK = 1;
                                   2156 ;	assignBit
      00074F D2 97            [12] 2157 	setb	_SCK
                                   2158 ;	main.c:664: TCK = 0;
                                   2159 ;	assignBit
      000751 C2 97            [12] 2160 	clr	_SCK
                                   2161 ;	main.c:666: TDI = P2B4;
                                   2162 ;	assignBit
      000753 A2 A4            [12] 2163 	mov	c,_P2B4
      000755 92 95            [24] 2164 	mov	_MOSI,c
                                   2165 ;	main.c:667: P2B4 = ASDO;
                                   2166 ;	assignBit
      000757 A2 B3            [12] 2167 	mov	c,_ASDO
      000759 92 A4            [24] 2168 	mov	_P2B4,c
                                   2169 ;	main.c:668: TCK = 1;
                                   2170 ;	assignBit
      00075B D2 97            [12] 2171 	setb	_SCK
                                   2172 ;	main.c:669: TCK = 0;
                                   2173 ;	assignBit
      00075D C2 97            [12] 2174 	clr	_SCK
                                   2175 ;	main.c:671: TDI = P2B5;
                                   2176 ;	assignBit
      00075F A2 A5            [12] 2177 	mov	c,_P2B5
      000761 92 95            [24] 2178 	mov	_MOSI,c
                                   2179 ;	main.c:672: P2B5 = ASDO;
                                   2180 ;	assignBit
      000763 A2 B3            [12] 2181 	mov	c,_ASDO
      000765 92 A5            [24] 2182 	mov	_P2B5,c
                                   2183 ;	main.c:673: TCK = 1;
                                   2184 ;	assignBit
      000767 D2 97            [12] 2185 	setb	_SCK
                                   2186 ;	main.c:674: TCK = 0;
                                   2187 ;	assignBit
      000769 C2 97            [12] 2188 	clr	_SCK
                                   2189 ;	main.c:676: TDI = P2B6;
                                   2190 ;	assignBit
      00076B A2 A6            [12] 2191 	mov	c,_P2B6
      00076D 92 95            [24] 2192 	mov	_MOSI,c
                                   2193 ;	main.c:677: P2B6 = ASDO;
                                   2194 ;	assignBit
      00076F A2 B3            [12] 2195 	mov	c,_ASDO
      000771 92 A6            [24] 2196 	mov	_P2B6,c
                                   2197 ;	main.c:678: TCK = 1;
                                   2198 ;	assignBit
      000773 D2 97            [12] 2199 	setb	_SCK
                                   2200 ;	main.c:679: TCK = 0;
                                   2201 ;	assignBit
      000775 C2 97            [12] 2202 	clr	_SCK
                                   2203 ;	main.c:681: TDI = P2B7;
                                   2204 ;	assignBit
      000777 A2 A7            [12] 2205 	mov	c,_P2B7
      000779 92 95            [24] 2206 	mov	_MOSI,c
                                   2207 ;	main.c:682: P2B7 = ASDO;
                                   2208 ;	assignBit
      00077B A2 B3            [12] 2209 	mov	c,_ASDO
      00077D 92 A7            [24] 2210 	mov	_P2B7,c
                                   2211 ;	main.c:683: TCK = 1;
                                   2212 ;	assignBit
      00077F D2 97            [12] 2213 	setb	_SCK
                                   2214 ;	main.c:684: TCK = 0;
                                   2215 ;	assignBit
      000781 C2 97            [12] 2216 	clr	_SCK
                                   2217 ;	main.c:685: return P2;
                                   2218 ;	main.c:862: transmit_buffer[transmit_buffer_in_offset] = shift_AS_read_on();
      000783 E5 A0            [12] 2219 	mov	a,_P2
      000785 FE               [12] 2220 	mov	r6,a
      000786 F0               [24] 2221 	movx	@dptr,a
                                   2222 ;	main.c:863: transmit_buffer_in_offset++;
      000787 78r06            [12] 2223 	mov	r0,#_transmit_buffer_in_offset
      000789 06               [12] 2224 	inc	@r0
                                   2225 ;	main.c:864: transmit_buffer_in_offset &= 0x7f;
      00078A 78r06            [12] 2226 	mov	r0,#_transmit_buffer_in_offset
      00078C E6               [12] 2227 	mov	a,@r0
      00078D 54 7F            [12] 2228 	anl	a,#0x7f
      00078F F6               [12] 2229 	mov	@r0,a
      000790 02r06r67         [24] 2230 	ljmp	00120$
      000793                       2231 00112$:
                                   2232 ;	main.c:866: transmit_buffer[transmit_buffer_in_offset] =shift_read_on() ;
      000793 78r06            [12] 2233 	mov	r0,#_transmit_buffer_in_offset
      000795 86 05            [24] 2234 	mov	ar5,@r0
      000797 7E 00            [12] 2235 	mov	r6,#(_transmit_buffer >> 8)
                                   2236 ;	main.c:637: CH554SPIMasterWrite(P2);
      000799 85 A0 82         [24] 2237 	mov	dpl,_P2
      00079C C0 07            [24] 2238 	push	ar7
      00079E C0 06            [24] 2239 	push	ar6
      0007A0 C0 05            [24] 2240 	push	ar5
      0007A2 C0 02            [24] 2241 	push	ar2
      0007A4 12r00r00         [24] 2242 	lcall	_CH554SPIMasterWrite
      0007A7 D0 02            [24] 2243 	pop	ar2
      0007A9 D0 05            [24] 2244 	pop	ar5
      0007AB D0 06            [24] 2245 	pop	ar6
      0007AD D0 07            [24] 2246 	pop	ar7
                                   2247 ;	main.c:638: return SPI0_DATA;
      0007AF AC F9            [24] 2248 	mov	r4,_SPI0_DATA
                                   2249 ;	main.c:866: transmit_buffer[transmit_buffer_in_offset] =shift_read_on() ;
      0007B1 8D 82            [24] 2250 	mov	dpl,r5
      0007B3 8E 83            [24] 2251 	mov	dph,r6
      0007B5 EC               [12] 2252 	mov	a,r4
      0007B6 F0               [24] 2253 	movx	@dptr,a
                                   2254 ;	main.c:867: transmit_buffer_in_offset++;
      0007B7 78r06            [12] 2255 	mov	r0,#_transmit_buffer_in_offset
      0007B9 06               [12] 2256 	inc	@r0
                                   2257 ;	main.c:868: transmit_buffer_in_offset &= 0x7f;
      0007BA 78r06            [12] 2258 	mov	r0,#_transmit_buffer_in_offset
      0007BC E6               [12] 2259 	mov	a,@r0
      0007BD 54 7F            [12] 2260 	anl	a,#0x7f
      0007BF F6               [12] 2261 	mov	@r0,a
      0007C0 02r06r67         [24] 2262 	ljmp	00120$
      0007C3                       2263 00115$:
                                   2264 ;	main.c:637: CH554SPIMasterWrite(P2);
      0007C3 85 A0 82         [24] 2265 	mov	dpl,_P2
      0007C6 C0 07            [24] 2266 	push	ar7
      0007C8 C0 02            [24] 2267 	push	ar2
      0007CA 12r00r00         [24] 2268 	lcall	_CH554SPIMasterWrite
      0007CD D0 02            [24] 2269 	pop	ar2
      0007CF D0 07            [24] 2270 	pop	ar7
                                   2271 ;	main.c:638: return SPI0_DATA;
      0007D1 E5 F9            [12] 2272 	mov	a,_SPI0_DATA
                                   2273 ;	main.c:880: shift_read_on();
      0007D3 02r06r67         [24] 2274 	ljmp	00120$
      0007D6                       2275 00122$:
                                   2276 ;	main.c:886: if (ep1_in_busy == 0) //端点不繁忙（空闲后的第一包数据，只用作触发上传）
      0007D6 78r04            [12] 2277 	mov	r0,#_ep1_in_busy
      0007D8 E6               [12] 2278 	mov	a,@r0
      0007D9 60 03            [24] 2279 	jz	00257$
      0007DB 02r06r30         [24] 2280 	ljmp	00137$
      0007DE                       2281 00257$:
                                   2282 ;	main.c:888: int8_t data_len = transmit_buffer_in_offset - transmit_buffer_out_offset;
      0007DE 78r06            [12] 2283 	mov	r0,#_transmit_buffer_in_offset
      0007E0 79r07            [12] 2284 	mov	r1,#_transmit_buffer_out_offset
      0007E2 E6               [12] 2285 	mov	a,@r0
      0007E3 C3               [12] 2286 	clr	c
      0007E4 97               [12] 2287 	subb	a,@r1
                                   2288 ;	main.c:889: data_len = data_len < 0 ? 128 + data_len : data_len;
      0007E5 FE               [12] 2289 	mov	r6,a
      0007E6 30 E7 06         [24] 2290 	jnb	acc.7,00147$
      0007E9 74 80            [12] 2291 	mov	a,#0x80
      0007EB 2E               [12] 2292 	add	a,r6
      0007EC FD               [12] 2293 	mov	r5,a
      0007ED 80 02            [24] 2294 	sjmp	00148$
      0007EF                       2295 00147$:
      0007EF 8E 05            [24] 2296 	mov	ar5,r6
      0007F1                       2297 00148$:
      0007F1 8D 06            [24] 2298 	mov	ar6,r5
                                   2299 ;	main.c:890: if (data_len > 0) // 2 for modem bytes.
      0007F3 C3               [12] 2300 	clr	c
      0007F4 74 80            [12] 2301 	mov	a,#(0x00 ^ 0x80)
      0007F6 8E F0            [24] 2302 	mov	b,r6
      0007F8 63 F0 80         [24] 2303 	xrl	b,#0x80
      0007FB 95 F0            [12] 2304 	subb	a,b
      0007FD 50 5B            [24] 2305 	jnc	00130$
                                   2306 ;	main.c:893: send_len = (data_len >= 62) ? 62 : data_len;
      0007FF C3               [12] 2307 	clr	c
      000800 EE               [12] 2308 	mov	a,r6
      000801 64 80            [12] 2309 	xrl	a,#0x80
      000803 94 BE            [12] 2310 	subb	a,#0xbe
      000805 92*01            [24] 2311 	mov	_main_sloc0_1_0,c
      000807 40 06            [24] 2312 	jc	00149$
      000809 7C 3E            [12] 2313 	mov	r4,#0x3e
      00080B 7D 00            [12] 2314 	mov	r5,#0x00
      00080D 80 06            [24] 2315 	sjmp	00150$
      00080F                       2316 00149$:
      00080F EE               [12] 2317 	mov	a,r6
      000810 FC               [12] 2318 	mov	r4,a
      000811 33               [12] 2319 	rlc	a
      000812 95 E0            [12] 2320 	subb	a,acc
      000814 FD               [12] 2321 	mov	r5,a
      000815                       2322 00150$:
      000815 78r08            [12] 2323 	mov	r0,#_send_len
      000817 A6 04            [24] 2324 	mov	@r0,ar4
                                   2325 ;	main.c:895: for (i = 0; i < send_len; i++)
      000819 7E 00            [12] 2326 	mov	r6,#0x00
      00081B                       2327 00143$:
      00081B C3               [12] 2328 	clr	c
      00081C EE               [12] 2329 	mov	a,r6
      00081D 9C               [12] 2330 	subb	a,r4
      00081E 50 2B            [24] 2331 	jnc	00123$
                                   2332 ;	main.c:897: Ep1Buffer[i + 2] = transmit_buffer[transmit_buffer_out_offset];
      000820 8E 05            [24] 2333 	mov	ar5,r6
      000822 0D               [12] 2334 	inc	r5
      000823 0D               [12] 2335 	inc	r5
      000824 ED               [12] 2336 	mov	a,r5
      000825 33               [12] 2337 	rlc	a
      000826 95 E0            [12] 2338 	subb	a,acc
      000828 FB               [12] 2339 	mov	r3,a
      000829 ED               [12] 2340 	mov	a,r5
      00082A 24 40            [12] 2341 	add	a,#_Ep1Buffer
      00082C FD               [12] 2342 	mov	r5,a
      00082D EB               [12] 2343 	mov	a,r3
      00082E 34 01            [12] 2344 	addc	a,#(_Ep1Buffer >> 8)
      000830 FB               [12] 2345 	mov	r3,a
      000831 78r07            [12] 2346 	mov	r0,#_transmit_buffer_out_offset
      000833 86 82            [24] 2347 	mov	dpl,@r0
      000835 75 83 00         [24] 2348 	mov	dph,#(_transmit_buffer >> 8)
      000838 E0               [24] 2349 	movx	a,@dptr
      000839 FA               [12] 2350 	mov	r2,a
      00083A 8D 82            [24] 2351 	mov	dpl,r5
      00083C 8B 83            [24] 2352 	mov	dph,r3
      00083E F0               [24] 2353 	movx	@dptr,a
                                   2354 ;	main.c:898: transmit_buffer_out_offset++;
      00083F 78r07            [12] 2355 	mov	r0,#_transmit_buffer_out_offset
      000841 06               [12] 2356 	inc	@r0
                                   2357 ;	main.c:899: transmit_buffer_out_offset &= 0x7f;// %= sizeof(transmit_buffer);
      000842 78r07            [12] 2358 	mov	r0,#_transmit_buffer_out_offset
      000844 E6               [12] 2359 	mov	a,@r0
      000845 54 7F            [12] 2360 	anl	a,#0x7f
      000847 F6               [12] 2361 	mov	@r0,a
                                   2362 ;	main.c:895: for (i = 0; i < send_len; i++)
      000848 0E               [12] 2363 	inc	r6
      000849 80 D0            [24] 2364 	sjmp	00143$
      00084B                       2365 00123$:
                                   2366 ;	main.c:924: ep1_in_busy = 1;
      00084B 78r04            [12] 2367 	mov	r0,#_ep1_in_busy
      00084D 76 01            [12] 2368 	mov	@r0,#0x01
                                   2369 ;	main.c:925: UEP1_T_LEN = send_len + 2;
      00084F 74 02            [12] 2370 	mov	a,#0x02
      000851 2C               [12] 2371 	add	a,r4
      000852 F5 D3            [12] 2372 	mov	_UEP1_T_LEN,a
                                   2373 ;	main.c:926: UEP1_CTRL = UEP1_CTRL & ~MASK_UEP_T_RES | UEP_T_RES_ACK; //应答ACK
      000854 53 D2 FC         [24] 2374 	anl	_UEP1_CTRL,#0xfc
      000857 02r06r30         [24] 2375 	ljmp	00137$
      00085A                       2376 00130$:
                                   2377 ;	main.c:928: else if ((sof_count - timeout_count) > latency_timer)
      00085A 78r02            [12] 2378 	mov	r0,#_sof_count
      00085C E6               [12] 2379 	mov	a,@r0
      00085D C3               [12] 2380 	clr	c
      00085E 95*14            [12] 2381 	subb	a,_main_timeout_count_65536_121
      000860 FD               [12] 2382 	mov	r5,a
      000861 08               [12] 2383 	inc	r0
      000862 E6               [12] 2384 	mov	a,@r0
      000863 95*15            [12] 2385 	subb	a,(_main_timeout_count_65536_121 + 1)
      000865 FE               [12] 2386 	mov	r6,a
      000866 78r05            [12] 2387 	mov	r0,#_latency_timer
      000868 86 03            [24] 2388 	mov	ar3,@r0
      00086A 7C 00            [12] 2389 	mov	r4,#0x00
      00086C C3               [12] 2390 	clr	c
      00086D EB               [12] 2391 	mov	a,r3
      00086E 9D               [12] 2392 	subb	a,r5
      00086F EC               [12] 2393 	mov	a,r4
      000870 9E               [12] 2394 	subb	a,r6
      000871 50 14            [24] 2395 	jnc	00127$
                                   2396 ;	main.c:930: timeout_count = sof_count;
      000873 78r02            [12] 2397 	mov	r0,#_sof_count
      000875 86*14            [24] 2398 	mov	_main_timeout_count_65536_121,@r0
      000877 08               [12] 2399 	inc	r0
      000878 86*15            [24] 2400 	mov	(_main_timeout_count_65536_121 + 1),@r0
                                   2401 ;	main.c:931: ep1_in_busy = 1;
      00087A 78r04            [12] 2402 	mov	r0,#_ep1_in_busy
      00087C 76 01            [12] 2403 	mov	@r0,#0x01
                                   2404 ;	main.c:932: UEP1_T_LEN = 2;											 //预使用发送长度一定要清空
      00087E 75 D3 02         [24] 2405 	mov	_UEP1_T_LEN,#0x02
                                   2406 ;	main.c:933: UEP1_CTRL = UEP1_CTRL & ~MASK_UEP_T_RES | UEP_T_RES_ACK; //应答ACK
      000881 53 D2 FC         [24] 2407 	anl	_UEP1_CTRL,#0xfc
      000884 02r06r30         [24] 2408 	ljmp	00137$
      000887                       2409 00127$:
                                   2410 ;	main.c:935: else if(send_dummy)
      000887 E5*06            [12] 2411 	mov	a,_send_dummy
      000889 70 03            [24] 2412 	jnz	00263$
      00088B 02r06r30         [24] 2413 	ljmp	00137$
      00088E                       2414 00263$:
                                   2415 ;	main.c:937: send_dummy--;
      00088E 15*06            [12] 2416 	dec	_send_dummy
                                   2417 ;	main.c:938: ep1_in_busy = 1;
      000890 78r04            [12] 2418 	mov	r0,#_ep1_in_busy
      000892 76 01            [12] 2419 	mov	@r0,#0x01
                                   2420 ;	main.c:939: UEP1_T_LEN = 2;											 //预使用发送长度一定要清空
      000894 75 D3 02         [24] 2421 	mov	_UEP1_T_LEN,#0x02
                                   2422 ;	main.c:940: UEP1_CTRL = UEP1_CTRL & ~MASK_UEP_T_RES | UEP_T_RES_ACK; //应答ACK
      000897 53 D2 FC         [24] 2423 	anl	_UEP1_CTRL,#0xfc
                                   2424 ;	main.c:945: }
      00089A 02r06r30         [24] 2425 	ljmp	00137$
                                   2426 	.area CSEG    (CODE)
                                   2427 	.area CONST   (CODE)
      000000                       2428 _ftdi_rom:
      000000 00                    2429 	.db #0x00	; 0
      000001 00                    2430 	.db #0x00	; 0
      000002 FB                    2431 	.db #0xfb	; 251
      000003 09                    2432 	.db #0x09	; 9
      000004 01                    2433 	.db #0x01	; 1
      000005 60                    2434 	.db #0x60	; 96
      000006 00                    2435 	.db #0x00	; 0
      000007 04                    2436 	.db #0x04	; 4
      000008 80                    2437 	.db #0x80	; 128
      000009 E1                    2438 	.db #0xe1	; 225
      00000A 1C                    2439 	.db #0x1c	; 28
      00000B 00                    2440 	.db #0x00	; 0
      00000C 00                    2441 	.db #0x00	; 0
      00000D 02                    2442 	.db #0x02	; 2
      00000E 94                    2443 	.db #0x94	; 148
      00000F 0E                    2444 	.db #0x0e	; 14
      000010 A2                    2445 	.db #0xa2	; 162
      000011 18                    2446 	.db #0x18	; 24
      000012 BA                    2447 	.db #0xba	; 186
      000013 12                    2448 	.db #0x12	; 18
      000014 0E                    2449 	.db #0x0e	; 14
      000015 03                    2450 	.db #0x03	; 3
      000016 41                    2451 	.db #0x41	; 65	'A'
      000017 00                    2452 	.db #0x00	; 0
      000018 6C                    2453 	.db #0x6c	; 108	'l'
      000019 00                    2454 	.db #0x00	; 0
      00001A 74                    2455 	.db #0x74	; 116	't'
      00001B 00                    2456 	.db #0x00	; 0
      00001C 65                    2457 	.db #0x65	; 101	'e'
      00001D 00                    2458 	.db #0x00	; 0
      00001E 72                    2459 	.db #0x72	; 114	'r'
      00001F 00                    2460 	.db #0x00	; 0
      000020 61                    2461 	.db #0x61	; 97	'a'
      000021 00                    2462 	.db #0x00	; 0
      000022 18                    2463 	.db #0x18	; 24
      000023 03                    2464 	.db #0x03	; 3
      000024 55                    2465 	.db #0x55	; 85	'U'
      000025 00                    2466 	.db #0x00	; 0
      000026 53                    2467 	.db #0x53	; 83	'S'
      000027 00                    2468 	.db #0x00	; 0
      000028 42                    2469 	.db #0x42	; 66	'B'
      000029 00                    2470 	.db #0x00	; 0
      00002A 2D                    2471 	.db #0x2d	; 45
      00002B 00                    2472 	.db #0x00	; 0
      00002C 42                    2473 	.db #0x42	; 66	'B'
      00002D 00                    2474 	.db #0x00	; 0
      00002E 6C                    2475 	.db #0x6c	; 108	'l'
      00002F 00                    2476 	.db #0x00	; 0
      000030 61                    2477 	.db #0x61	; 97	'a'
      000031 00                    2478 	.db #0x00	; 0
      000032 73                    2479 	.db #0x73	; 115	's'
      000033 00                    2480 	.db #0x00	; 0
      000034 74                    2481 	.db #0x74	; 116	't'
      000035 00                    2482 	.db #0x00	; 0
      000036 65                    2483 	.db #0x65	; 101	'e'
      000037 00                    2484 	.db #0x00	; 0
      000038 72                    2485 	.db #0x72	; 114	'r'
      000039 00                    2486 	.db #0x00	; 0
      00003A 12                    2487 	.db #0x12	; 18
      00003B 03                    2488 	.db #0x03	; 3
      00003C 43                    2489 	.db #0x43	; 67	'C'
      00003D 00                    2490 	.db #0x00	; 0
      00003E 30                    2491 	.db #0x30	; 48	'0'
      00003F 00                    2492 	.db #0x00	; 0
      000040 42                    2493 	.db #0x42	; 66	'B'
      000041 00                    2494 	.db #0x00	; 0
      000042 46                    2495 	.db #0x46	; 70	'F'
      000043 00                    2496 	.db #0x00	; 0
      000044 41                    2497 	.db #0x41	; 65	'A'
      000045 00                    2498 	.db #0x00	; 0
      000046 36                    2499 	.db #0x36	; 54	'6'
      000047 00                    2500 	.db #0x00	; 0
      000048 44                    2501 	.db #0x44	; 68	'D'
      000049 00                    2502 	.db #0x00	; 0
      00004A 37                    2503 	.db #0x37	; 55	'7'
      00004B 00                    2504 	.db #0x00	; 0
      00004C 02                    2505 	.db #0x02	; 2
      00004D 03                    2506 	.db #0x03	; 3
      00004E 01                    2507 	.db #0x01	; 1
      00004F 00                    2508 	.db #0x00	; 0
      000050 52                    2509 	.db #0x52	; 82	'R'
      000051 45                    2510 	.db #0x45	; 69	'E'
      000052 56                    2511 	.db #0x56	; 86	'V'
      000053 42                    2512 	.db #0x42	; 66	'B'
      000054 00                    2513 	.db #0x00	; 0
      000055 00                    2514 	.db #0x00	; 0
      000056 00                    2515 	.db #0x00	; 0
      000057 00                    2516 	.db #0x00	; 0
      000058 00                    2517 	.db #0x00	; 0
      000059 00                    2518 	.db #0x00	; 0
      00005A 00                    2519 	.db #0x00	; 0
      00005B 00                    2520 	.db #0x00	; 0
      00005C 00                    2521 	.db #0x00	; 0
      00005D 00                    2522 	.db #0x00	; 0
      00005E 00                    2523 	.db #0x00	; 0
      00005F 00                    2524 	.db #0x00	; 0
      000060 00                    2525 	.db #0x00	; 0
      000061 00                    2526 	.db #0x00	; 0
      000062 00                    2527 	.db #0x00	; 0
      000063 00                    2528 	.db #0x00	; 0
      000064 00                    2529 	.db #0x00	; 0
      000065 00                    2530 	.db #0x00	; 0
      000066 00                    2531 	.db #0x00	; 0
      000067 00                    2532 	.db #0x00	; 0
      000068 00                    2533 	.db #0x00	; 0
      000069 00                    2534 	.db #0x00	; 0
      00006A 00                    2535 	.db #0x00	; 0
      00006B 00                    2536 	.db #0x00	; 0
      00006C 00                    2537 	.db #0x00	; 0
      00006D 00                    2538 	.db #0x00	; 0
      00006E 00                    2539 	.db #0x00	; 0
      00006F 00                    2540 	.db #0x00	; 0
      000070 00                    2541 	.db #0x00	; 0
      000071 00                    2542 	.db #0x00	; 0
      000072 00                    2543 	.db #0x00	; 0
      000073 00                    2544 	.db #0x00	; 0
      000074 00                    2545 	.db #0x00	; 0
      000075 00                    2546 	.db #0x00	; 0
      000076 00                    2547 	.db #0x00	; 0
      000077 00                    2548 	.db #0x00	; 0
      000078 00                    2549 	.db #0x00	; 0
      000079 00                    2550 	.db #0x00	; 0
      00007A 00                    2551 	.db #0x00	; 0
      00007B 00                    2552 	.db #0x00	; 0
      00007C 00                    2553 	.db #0x00	; 0
      00007D 00                    2554 	.db #0x00	; 0
      00007E B5                    2555 	.db #0xb5	; 181
      00007F B2                    2556 	.db #0xb2	; 178
      000080                       2557 _DevDesc:
      000080 12                    2558 	.db #0x12	; 18
      000081 01                    2559 	.db #0x01	; 1
      000082 00                    2560 	.db #0x00	; 0
      000083 02                    2561 	.db #0x02	; 2
      000084 00                    2562 	.db #0x00	; 0
      000085 00                    2563 	.db #0x00	; 0
      000086 00                    2564 	.db #0x00	; 0
      000087 08                    2565 	.db #0x08	; 8
      000088 FB                    2566 	.db #0xfb	; 251
      000089 09                    2567 	.db #0x09	; 9
      00008A 01                    2568 	.db #0x01	; 1
      00008B 60                    2569 	.db #0x60	; 96
      00008C 00                    2570 	.db #0x00	; 0
      00008D 04                    2571 	.db #0x04	; 4
      00008E 01                    2572 	.db #0x01	; 1
      00008F 02                    2573 	.db #0x02	; 2
      000090 03                    2574 	.db #0x03	; 3
      000091 01                    2575 	.db #0x01	; 1
      000092                       2576 _CfgDesc:
      000092 09                    2577 	.db #0x09	; 9
      000093 02                    2578 	.db #0x02	; 2
      000094 20                    2579 	.db #0x20	; 32
      000095 00                    2580 	.db #0x00	; 0
      000096 01                    2581 	.db #0x01	; 1
      000097 01                    2582 	.db #0x01	; 1
      000098 00                    2583 	.db #0x00	; 0
      000099 80                    2584 	.db #0x80	; 128
      00009A E1                    2585 	.db #0xe1	; 225
      00009B 09                    2586 	.db #0x09	; 9
      00009C 04                    2587 	.db #0x04	; 4
      00009D 00                    2588 	.db #0x00	; 0
      00009E 00                    2589 	.db #0x00	; 0
      00009F 02                    2590 	.db #0x02	; 2
      0000A0 FF                    2591 	.db #0xff	; 255
      0000A1 FF                    2592 	.db #0xff	; 255
      0000A2 FF                    2593 	.db #0xff	; 255
      0000A3 00                    2594 	.db #0x00	; 0
      0000A4 07                    2595 	.db #0x07	; 7
      0000A5 05                    2596 	.db #0x05	; 5
      0000A6 81                    2597 	.db #0x81	; 129
      0000A7 02                    2598 	.db #0x02	; 2
      0000A8 40                    2599 	.db #0x40	; 64
      0000A9 00                    2600 	.db #0x00	; 0
      0000AA 01                    2601 	.db #0x01	; 1
      0000AB 07                    2602 	.db #0x07	; 7
      0000AC 05                    2603 	.db #0x05	; 5
      0000AD 02                    2604 	.db #0x02	; 2
      0000AE 02                    2605 	.db #0x02	; 2
      0000AF 40                    2606 	.db #0x40	; 64
      0000B0 00                    2607 	.db #0x00	; 0
      0000B1 01                    2608 	.db #0x01	; 1
      0000B2                       2609 _LangDes:
      0000B2 04                    2610 	.db #0x04	; 4
      0000B3 03                    2611 	.db #0x03	; 3
      0000B4 09                    2612 	.db #0x09	; 9
      0000B5 04                    2613 	.db #0x04	; 4
      0000B6                       2614 _SerDes:
      0000B6 12                    2615 	.db #0x12	; 18
      0000B7 03                    2616 	.db #0x03	; 3
      0000B8 43                    2617 	.db #0x43	; 67	'C'
      0000B9 00                    2618 	.db #0x00	; 0
      0000BA 30                    2619 	.db #0x30	; 48	'0'
      0000BB 00                    2620 	.db #0x00	; 0
      0000BC 42                    2621 	.db #0x42	; 66	'B'
      0000BD 00                    2622 	.db #0x00	; 0
      0000BE 46                    2623 	.db #0x46	; 70	'F'
      0000BF 00                    2624 	.db #0x00	; 0
      0000C0 41                    2625 	.db #0x41	; 65	'A'
      0000C1 00                    2626 	.db #0x00	; 0
      0000C2 36                    2627 	.db #0x36	; 54	'6'
      0000C3 00                    2628 	.db #0x00	; 0
      0000C4 44                    2629 	.db #0x44	; 68	'D'
      0000C5 00                    2630 	.db #0x00	; 0
      0000C6 37                    2631 	.db #0x37	; 55	'7'
      0000C7 00                    2632 	.db #0x00	; 0
      0000C8                       2633 _Prod_Des:
      0000C8 18                    2634 	.db #0x18	; 24
      0000C9 03                    2635 	.db #0x03	; 3
      0000CA 55                    2636 	.db #0x55	; 85	'U'
      0000CB 00                    2637 	.db #0x00	; 0
      0000CC 53                    2638 	.db #0x53	; 83	'S'
      0000CD 00                    2639 	.db #0x00	; 0
      0000CE 42                    2640 	.db #0x42	; 66	'B'
      0000CF 00                    2641 	.db #0x00	; 0
      0000D0 2D                    2642 	.db #0x2d	; 45
      0000D1 00                    2643 	.db #0x00	; 0
      0000D2 42                    2644 	.db #0x42	; 66	'B'
      0000D3 00                    2645 	.db #0x00	; 0
      0000D4 6C                    2646 	.db #0x6c	; 108	'l'
      0000D5 00                    2647 	.db #0x00	; 0
      0000D6 61                    2648 	.db #0x61	; 97	'a'
      0000D7 00                    2649 	.db #0x00	; 0
      0000D8 73                    2650 	.db #0x73	; 115	's'
      0000D9 00                    2651 	.db #0x00	; 0
      0000DA 74                    2652 	.db #0x74	; 116	't'
      0000DB 00                    2653 	.db #0x00	; 0
      0000DC 65                    2654 	.db #0x65	; 101	'e'
      0000DD 00                    2655 	.db #0x00	; 0
      0000DE 72                    2656 	.db #0x72	; 114	'r'
      0000DF 00                    2657 	.db #0x00	; 0
      0000E0                       2658 _Manuf_Des:
      0000E0 0E                    2659 	.db #0x0e	; 14
      0000E1 03                    2660 	.db #0x03	; 3
      0000E2 41                    2661 	.db #0x41	; 65	'A'
      0000E3 00                    2662 	.db #0x00	; 0
      0000E4 6C                    2663 	.db #0x6c	; 108	'l'
      0000E5 00                    2664 	.db #0x00	; 0
      0000E6 74                    2665 	.db #0x74	; 116	't'
      0000E7 00                    2666 	.db #0x00	; 0
      0000E8 65                    2667 	.db #0x65	; 101	'e'
      0000E9 00                    2668 	.db #0x00	; 0
      0000EA 72                    2669 	.db #0x72	; 114	'r'
      0000EB 00                    2670 	.db #0x00	; 0
      0000EC 61                    2671 	.db #0x61	; 97	'a'
      0000ED 00                    2672 	.db #0x00	; 0
                                   2673 	.area XINIT   (CODE)
                                   2674 	.area CABS    (ABS,CODE)
